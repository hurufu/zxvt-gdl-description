% Not quite Capture of the Territory
% 1 player
% Board 3Ã—3
% No buildings
% Pawns can't be stacked and only single pawn can be placed on the board
% Goal is to capture the whole board

% WARNING: Remove to get valid program in GDL-II (HRF)
:- op(1000, xfy, '&').
:- op(1100, xfy, '|').
:- op(900, fy, '~').
:- op(920,fy, '*').
:- op(920,fy, '#').
:- initialization(all_tests_are_passing).

% Configuration
max_row(3).
max_col(3).
max_stack(1).
start_position(red, rc(1,1)).
rich_ui(no_rich_ui).%Avoid exception if all UI enrichments are disabled
rich_ui(last_roll).
rules(Player, captured_by(Player), [nothing,  nothing, nothing, nothing, nothing, nothing]) :- player(Player).
rules(Player, wild,                [minusone, nothing, nothing, capture, capture, capture]) :- player(Player).

% TODO: Consider something similar as a future rules
rules(situation(army(of(P), count(     X )), on(Tile,  owned_by(P))), die(D), situation(army(of(P), count(     X )), on(Tile,  owned_by(P)))) :- player(P) & tile(Tile) & d6(D) & is_succ(X).
rules(situation(army(of(P), count(succ(X))), on(field,        wild)), die(1), situation(army(of(P), count(     X )), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(2), situation(army(of(P), count(     X )), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(3), situation(army(of(P), count(     X )), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(4), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(5), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(6), situation(army(of(P), count(succ(X))), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(succ(X))), on(field, owned_by(Q))), die(1), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(2), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(3), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(4), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(5), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(6), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
%rules(situation(army(of(P), count(X)), on(town,  owned_by(Q))), die(D), situation(army(of(P), count(Y)), on(town,  owned_by(Q)))) :- (D = 1; D = 2), Y #= X-1, P \= Q.
%rules(situation(army(of(P), count(X)), on(town,  owned_by(Q))), die(D), situation(army(of(P), count(X)), on(town,  owned_by(Q)))) :- (D = 3; D = 4), P \= Q.
%rules(situation(army(of(P), count(X)), on(town,  owned_by(Q))), die(D), situation(army(of(P), count(X)), on(town,  owned_by(P)))) :- (D = 5; D = 6), P \= Q.

% GDL
role(random).
role(red).

% Number of rolled dice shouldn't exceed allowed pawn stack size
input(random, roll(L)) :-
    roll_d6(M, L) &
    stack(M).
input(Player, move(NumberOfPawns, from(From), to(To))) :-
    player(Player) &
    stack(NumberOfPawns) &
    neighboring_coordinates(From, To).
% New pawn can be spawned only at player's starting position
input(Player, spawn(at(StartPosition))) :-
    start_position(Player, StartPosition).

base(Cell) :- valid_cell(Cell).
base(control(R)) :- player(R).
base(last_roll(D6, Outcome)) :-
    rich_ui(last_roll) &
    d6(D6) &
    outcome(Outcome).

init(cell(StartPosition, captured_by(Player), with_pawn(of(Player), number(1)))) :-
    start_position(Player, StartPosition).
init(cell(Rc, wild, free)) :-
    valid_cell(cell(Rc, wild, free)) &
    start_position(_, StartPosition) &
    distinct(StartPosition, Rc).
init(control(red)).

% TODO: Number of dice thrown should be equal to the largest player's pawn stack
legal(random, roll([D6])) :-
    true(control(Player)) &
    player(Player) &
    d6(D6).
legal(Player, move(MovingPawns, from(From), to(To))) :-
    true(control(Player)) &
    true(cell(From, _, with_pawn(of(Player), number(StationaryPawns)))) &
    player(Player) &
    neighboring_coordinates(From, To) &
    stack(MovingPawns) &
    le(MovingPawns, StationaryPawns).
legal(Player, spawn(at(rc(1,1)))) :-
    true(control(Player)) &
    true_for_each_cell_occupation(free).

goal(random, 0).
goal(Player, Score) :-
    player_score(Player, Score).

% Games ends if all board is captured
terminal :-
    player(Player) &
    true_for_each_cell(captured_by(Player)).

% TODO: Game ends if an opposite side of a board is captured
%terminal :-
%    player(red) &
%    cell(rc(3,3), captured_by(red), _).

next(cell(FromAndTo, captured_by(Player), with_pawn(of(Player), number(MovingPawns)))) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, capture).

next(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, nothing).

next(cell(FromAndTo, OldCapture, free)) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, minusone).

% Destination is captured by player according to rule book and all pawns appear there
next(cell(To, captured_by(Player), with_pawn(of(Player), number(MovingPawns)))) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D, Capture, capture).

next(cell(To, Capture, with_pawn(of(Player), number(MovingPawns)))) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D, Capture, nothing).

next(cell(To, Capture, free)) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(_, from(From), to(To))) &
    true(cell(To, Capture, _)) &
    distinct(From, To) &
    rule_outcome(Player, D, Capture, minusone).

% Origin retains its capture state and ALL pawns are removed
next(cell(From, OldCapture, free)) :-
    player(Player) &
    does(random, _) &
    does(Player, move(_, from(From), to(To))) &
    distinct(From, To) &
    true(cell(From, OldCapture, _)).

% All other cells should retains their respective state
next(cell(Rc, OldCapture, OldPawnState)) :-
    player(Player) &
    does(random, _) &
    does(Player, move(_, from(From), to(To))) &
    true(cell(Rc, OldCapture, OldPawnState)) &
    distinct(Rc, From) &
    distinct(Rc, To).

% All other cells should retains their respective state
next(cell(Rc, OldCapture, OldPawnState)) :-
    does(_, spawn(at(Spawn))) &
    true(cell(Rc, OldCapture, OldPawnState)) &
    distinct(Rc, Spawn).

next(cell(Spawn, OldCapture, with_pawn(of(Player), number(1)))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, OldCapture, _)).

% There is no transfer of control
next(control(Player)) :-
    player(Player) &
    true(control(Player)).

next(last_roll(D6, Outcome)) :-
    rich_ui(last_roll) &
    player(Player) &
    does(random, roll([D6])) &
    does(Player, move(_, from(_), to(To))) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D6, Capture, Outcome).

% Input utils
player_score(Player, 100) :-
    true_for_each_cell(captured_by(Player)).
player_score(Player, 50) :-
    true(cell(_, wild, _)) &
    true(cell(_, captured_by(Player), _)).
player_score(Player, 0) :-
    player(Player) &% Fixes unsafe rule warning
    true_for_each_cell(wild).

%% TODO: Implement it in GDL
%alt_player_score(Player, NumberOfCapturedCells) :-
%    player(Player) &
%    findall(I, (I=cell(_, captured_by(Player), _), true(I)), L) &
%    length(L, NumberOfCapturedCells).

true_for_each_cell(Capture) :-
    true(cell(rc(1,1), Capture, _)) &
    true(cell(rc(1,2), Capture, _)) &
    true(cell(rc(1,3), Capture, _)) &
    true(cell(rc(2,1), Capture, _)) &
    true(cell(rc(2,2), Capture, _)) &
    true(cell(rc(2,3), Capture, _)) &
    true(cell(rc(3,1), Capture, _)) &
    true(cell(rc(3,2), Capture, _)) &
    true(cell(rc(3,3), Capture, _)).

true_for_each_cell_occupation(Occupation) :-
    true(cell(rc(1,1), _, Occupation)) &
    true(cell(rc(1,2), _, Occupation)) &
    true(cell(rc(1,3), _, Occupation)) &
    true(cell(rc(2,1), _, Occupation)) &
    true(cell(rc(2,2), _, Occupation)) &
    true(cell(rc(2,3), _, Occupation)) &
    true(cell(rc(3,1), _, Occupation)) &
    true(cell(rc(3,2), _, Occupation)) &
    true(cell(rc(3,3), _, Occupation)).

% Utils with complete definitions
row(I) :-
    max_row(MaxRow) &
    le(1, I) & le(I, MaxRow).

col(I) :-
    max_col(MaxCol) &
    le(1, I) & le(I, MaxCol).

stack(PossiblePawnStack) :-
    max_stack(MaxStack) &
    le(1, PossiblePawnStack) & le(PossiblePawnStack, MaxStack).

neighboring_coordinates(A, B) :-
    coordinates(A) &
    coordinates(B) &
    neighboring_coordinates_aux(A, B).
neighboring_coordinates_aux(rc(R,C), rc(R,C)) :- is_number(R) & is_number(C).
neighboring_coordinates_aux(rc(R,Lc), rc(R,Rc)) :- is_number(R) & s(Lc, Rc).
neighboring_coordinates_aux(rc(R,Lc), rc(R,Rc)) :- is_number(R) & s(Rc, Lc).
neighboring_coordinates_aux(rc(Lr,C), rc(Rr,C)) :- is_number(C) & s(Lr, Rr).
neighboring_coordinates_aux(rc(Lr,C), rc(Rr,C)) :- is_number(C) & s(Rr, Lr).

roll_d6(0, []).
roll_d6(1, [R1]) :- d6(R1).
roll_d6(2, [R1,R2]) :- d6(R1) & d6(R2).
roll_d6(3, [R1,R2,R3]) :- d6(R1) & d6(R2) & d6(R3).
roll_d6(4, [R1,R2,R3,R4]) :- d6(R1) & d6(R2) & d6(R3) & d6(R4).

counted_dice(dice(D6), X) :-
    roll_d6(N, D6) &
    sc(N, X).

head_tail_of_dice(R1, [], dice([R1])) :- roll_d6(_, [R1]).
head_tail_of_dice(R1, [R2], dice([R1,R2])) :- roll_d6(_, [R1,R2]).
head_tail_of_dice(R1, [R2,R3], dice([R1,R2,R3])) :- roll_d6(_, [R1,R2,R3]).
head_tail_of_dice(R1, [R2,R3,R4], dice([R1,R2,R3,R4])) :- roll_d6(_, [R1,R2,R3,R4]).

nth_element_d6(1, [R1,R2,R3,R4,R5,R6], R1) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(2, [R1,R2,R3,R4,R5,R6], R2) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(3, [R1,R2,R3,R4,R5,R6], R3) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(4, [R1,R2,R3,R4,R5,R6], R4) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(5, [R1,R2,R3,R4,R5,R6], R5) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(6, [R1,R2,R3,R4,R5,R6], R6) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).

outcome(capture).
outcome(nothing).
outcome(minusone).

tile(field).
%tile(town).

valid_situation_0(situation(army(Of, count(0)), On)) :-
    valid_situation(situation(army(Of, count(0)), On)).
valid_situation(situation(army(of(P), count(X)), on(Tile,  wild))) :-
    valid_situation_aux(P, X, Tile).
valid_situation(situation(army(of(P), count(X)), on(Tile,  owned_by(Q)))) :-
    valid_situation_aux(P, X, Tile) &
    player(Q).
valid_situation_aux(Player, Count, Tile) :-
    player(Player) &
    is_succ(Count) &
    tile(Tile).

unify_situation(A, A) :-
    valid_situation(A).
unify_dice(dice(A), dice(A)) :-
    roll_d6(_, A).
count_of_situation(situation(army(Of, count(X)), On), X) :-
    valid_situation(situation(army(Of, count(X)), On)).
nrules(S, dice([]), S) :-
    valid_situation_0(S).
nrules(Before, Roll, situation(army(ReturnArmy, count(A)), ReturnOn)) :-
    head_tail_of_dice(D6, T, Roll) &
    counted_dice(Roll, succ(N)) &
    count_of_situation(Before, succ(N)) &
    rules(Before, die(D6), situation(army(Of, count(C)), On)) &
    unify_dice(dice(T), DiceTail) &
    nrules(Next, DiceTail, Return) &
    add(A, succ(N), Tmp) & add(succ(R), C, Tmp) &
    valid_situation(situation(army(ReturnArmy, count(A)), ReturnOn)) &
    unify_situation(situation(army(Of, count(N)), On), Next) &
    unify_situation(situation(army(ReturnArmy, count(R)), ReturnOn), Return).

rule_outcome(Player, D6, CaptureType, Outcome) :-
    rules(Player, CaptureType, OutcomeList) &
    nth_element_d6(D6, OutcomeList, Outcome).

player(Player) :-
    role(Player) &
    distinct(random, Player).

valid_cell(cell(Coordinates, Type, WithPawn)) :-
    coordinates(Coordinates) &
    cell_type(Type) &
    valid_pawn(WithPawn).

coordinates(rc(Row, Column)) :- row(Row) & col(Column).

cell_type(wild).
cell_type(captured_by(Player)) :-
    player(Player).
valid_pawn(free).
valid_pawn(with_pawn(of(Player), number(Number))) :-
    player(Player) &
    stack(Number).

% All possible values that a D6 can produce
%d6(V) :-
%    le(1, V) & le(V, 6).
% Same, but faster
d6(1). d6(2). d6(3). d6(4). d6(5). d6(6).

is_number(N) :-
    s(N, _).

is_succ(X) :- sc(_, X).

% A is less then or equal to B
le(A, B) :- is_number(B) & s(A, X) & le(X, B).
le(A, A) :- is_number(A).

% Successor
s( 0, 1). s( 1, 2). s( 2, 3). s( 3, 4). s( 4, 5). s( 5, 6). s( 6, 7). s( 7, 8). % s( 8, 9). s( 9,10).
%s(10,11). s(11,12). s(12,13). s(13,14). s(14,15). s(15,16). s(16,17). s(17,18). s(18,19). s(19,20).
%s(20,21). s(21,22). s(22,23). s(23,24). s(24,25). s(25,26). s(26,27). s(27,28). s(28,29). s(29,30).
%s(30,31). s(31,32). s(32,33). s(33,34). s(34,35). s(35,36). s(36,37). s(37,38). s(38,39). s(39,40).
%s(40,41). s(41,42). s(42,43). s(43,44). s(44,45). s(45,46). s(46,47). s(47,48). s(48,49). s(49,50).
%s(50,51). s(51,52). s(52,53). s(53,54). s(54,55). s(55,56). s(56,57). s(57,58). s(58,59). s(59,60).
%s(60,61). s(61,62). s(62,63). s(63,64). s(64,65). s(65,66). s(66,67). s(67,68). s(68,69). s(69,70).
%s(70,71). s(71,72). s(72,73). s(73,74). s(74,75). s(75,76). s(76,77). s(77,78). s(78,79). s(79,80).
%s(80,81). s(81,82). s(82,83). s(83,84). s(84,85). s(85,86). s(86,87). s(87,88). s(88,89). s(89,90).
%s(90,91). s(91,92). s(92,93). s(93,94). s(94,95). s(95,96). s(96,97). s(97,98). s(98,99). s(99,100).

% Alternative succesors (probably faster)
sc( 0, 0).
sc( 1, succ(0)).
sc( 2, succ(succ(0))).
sc( 3, succ(succ(succ(0)))).
sc( 4, succ(succ(succ(succ(0))))).
sc( 5, succ(succ(succ(succ(succ(0)))))).
sc( 6, succ(succ(succ(succ(succ(succ(0))))))).
sc( 7, succ(succ(succ(succ(succ(succ(succ(0)))))))).
sc( 8, succ(succ(succ(succ(succ(succ(succ(succ(0))))))))).
sc( 9, succ(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))).
sc(10, succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(0))))))))))).

uni(A, succ(A)) :- is_succ(A).

add(0, B, B) :- is_succ(B).
add(A, B, succ(C)) :-
    uni(Am1, A) &
    add(Am1, B, C) &
    is_succ(B) &
    is_succ(C).

% Tests
% TODO: Perform tests for all possible board configurations
% TODO: All players have at least 1 legal move in current non-terminal state
all_statements_about_current_configuration_are_valid :-
    \+invalid_statement_for_current_configuration_exists(_).
invalid_statement_for_current_configuration_exists(I) :-
    true(I),
    \+base(I).

all_legal_moves_for_current_configuration_are_valid :-
    \+invalid_but_legal_move_for_current_configuration_exists(_, _).
invalid_but_legal_move_for_current_configuration_exists(Role, Move) :-
    legal(Role, Move),
    \+input(Role, Move).

all_roles_have_a_score_for_current_configuration :-
    \+there_is_a_role_without_a_score_for_current_configuration(_).
there_is_a_role_without_a_score_for_current_configuration(Role) :-
    role(Role),
    \+goal(Role, _).

all_scores_are_unambiguous_for_current_configuration :-
    \+there_is_a_role_with_ambiguous_score(_).
there_is_a_role_with_ambiguous_score(Role) :-
    role(Role),
    \+role_scores_are_unambiguous(Role).
role_scores_are_unambiguous(Role) :-
    findall(Score, (goal(Role, Score)), AllScores),
    list_of_identical_values(AllScores).

user_cannot_move_0_pawns :-
    \+pawn_0.
pawn_0 :-
    stack(NumberOfAllowedPawns),
    \+le(0, NumberOfAllowedPawns).

current_state_is_not_terminal :-
    \+terminal.

all_arithmetics_tests_are_passing :-
    add(succ(0), succ(succ(0)), succ(succ(succ(0)))),
    \+add(succ(0), succ(succ(0)), succ(succ(0))).

all_rules_tests_are_passing :-
    rules_should_terminate_if_count_is_set_but_dice_list_is_not(_, _),
    rules_should_terminate_if_dice_list_is_set_but_count_is_not(_, _),
    all_rules(red-on(field, wild), [6,6,1,1], [situation(army(of(red), count( succ(succ(succ(succ(0)))) )), on(field,wild))]),
    all_rules(red-on(field, wild), [2,1,1,4], [situation(army(of(red), count( succ(succ(0))  )), on(field,owned_by(red)))]),
    all_rules(red-on(field, wild), [1,2,5,6], [situation(army(of(red), count( succ(succ(succ(0))) )), on(field,owned_by(red)))]),
    all_rules(red-on(field, owned_by(red)), [1], [situation(army(of(red), count( succ(0) )), on(field,owned_by(red)))]).

rules_should_terminate_if_count_is_set_but_dice_list_is_not(L0, L1) :-
    findall(D, (nrules(situation(army(of(red), count(0)), on(field, wild)), D, _)), L0),
    findall(D, (nrules(situation(army(of(red), count(1)), on(field, wild)), D, _)), L1).
rules_should_terminate_if_dice_list_is_set_but_count_is_not(L0, L1) :-
    findall(Before, (nrules(Before, dice([]), _)), L0),
    findall(Before, (nrules(Before, dice([1]), _)), L1).
all_rules(Player-On, Dice, AllPossibleOutcomes) :-
    findall(After, nrules(situation(army(of(Player), count(_)), On), dice(Dice), After), AllPossibleOutcomes).

all_tests_are_passing :-
    all_statements_about_current_configuration_are_valid,
    all_legal_moves_for_current_configuration_are_valid,
    all_roles_have_a_score_for_current_configuration,
    all_scores_are_unambiguous_for_current_configuration,
    current_state_is_not_terminal,
    all_rules_tests_are_passing,
    all_arithmetics_tests_are_passing,
    user_cannot_move_0_pawns.

list_of_identical_values([]).
list_of_identical_values([H|T]) :-
    value_of_all_elements_of_a_list(H, T).
value_of_all_elements_of_a_list(_, []).
value_of_all_elements_of_a_list(H, [H|T]) :-
    value_of_all_elements_of_a_list(H, T).

% Assert that current configuration is initial
true(X) :- init(X).

'&'(Lhs, Rhs) :-
    call(Lhs), call(Rhs).
'|'(Lhs, Rhs) :-
    call(Lhs) ; call(Rhs).
'~'(Rhs) :-
    \+ call(Rhs).
'*'(_).
'#'(Goal) :-
    portray_clause(user_error, Goal),
    call(Goal).

% FIXME: It looks like distinct/2 should behave like dif/2
distinct(A, B) :- A \= B.
