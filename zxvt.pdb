% Not quite Capture of the Territory
% 1 player
% Board 3Ã—3
% No buildings
% Pawns can't be stacked and only single pawn can be placed on the board
% Goal is to capture the whole board
% Each player is movin simultaneously with a random role
% TODO: Consider adding different game tactic, where each roles moves separately
% TODO: Consider rewriting base proposition to verify no a single cell, but a
% whole board, so it can check for example if a cell dissapears.

% WARNING: Remove to get valid program in GDL-II (HRF)
:- op(1000, xfy, '&').
:- op(1100, xfy, '|').
:- op(900, fy, '~').
:- op(950, fy, '*').
:- op(900, fy, '$').
:- op(900, fy, '$-').
:- op(900, fy, '?').
:- op(900, fy, '-?').
:- op(1050, xfy, '~>').
:- initialization(all_tests_are_passing).

% Configuration %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

max_row(3).
max_col(3).
player(red).
start_position(red, rc(1,1)).
player_next(red, red).
%Avoid exception if all UI enrichments are disabled
rich_ui(no_rich_ui).
%rich_ui(last_roll).
%rich_ui(last_move).
%rich_ui(last_cell).
%rules(own,     field,    [nothing ,nothing ,nothing ,nothing ,nothing,nothing]).
%rules(wild,    field,    [minus(1),nothing ,nothing ,capture ,capture,plus(1)]).
%%rules(wild,    town,     [minus(1),minus(1),nothing ,capture ,plus(1),plus(1)]).
%%rules(wild,    garrison, [minus(1),minus(1),minus(1),nothing ,capture,plus(1)]).
%%rules(wild,    fort,     [minus(1),minus(1),minus(1),capture ,plus(1),plus(1)]).
%rules(foreign, field,    [minus(1),minus(1),nothing ,nothing ,capture,capture]).
%rules(foreign, town,     [minus(1),minus(1),nothing ,nothing ,nothing,capture]).
%rules(foreign, garrison, [minus(1),minus(1),minus(1),nothing ,capture,capture]).
%rules(foreign, fort,     [minus(1),minus(1),minus(1),minus(1),nothing,capture]).
rules(own,     field,    [nothing ,nothing,nothing,nothing]).
rules(wild,    field,    [minus(1),nothing,capture,plus(1)]).

% GDL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

role(random).
role(red).

% Random player can only roll a list of dice (D6)
% TODO: Consider making number of die sides configurable
input(random, roll(L)) :-
    valid_dice(L).
% Any player can move at least 1 pawn to any neighboring cell
input(Player, Move) :-
    player(Player) &
    valid_move(Move).
% Any player can spawn pawns only at a starting position
input(Player, spawn(at(StartPosition))) :-
    start_position(Player, StartPosition).
% Any player should wait when it's not his move
input(Player, noop) :-
    player(Player).

base(Cell) :-
    unify_cell(Cell, cell(_, situation(army(of(_), count(X)), _))) &
    le(1, X).
base(Cell) :-
    unify_cell(Cell, cell(_, situation(nobody, _))).
base(control(R)) :- player(R).
%base(last_roll(D)) :-
%    rich_ui(last_roll) &
%    valid_dice(D).
%base(last_move(Player, Move)) :-
%    player(Player) &
%    valid_move(Move).
%base(last_cell(Cell)) :-
%    valid_cell(Cell).
%base(before_last_roll(D)) :-
%    rich_ui(last_roll) &
%    valid_dice(D).
%base(before_last_move(Player, Move)) :-
%    player(Player) &
%    valid_move(Move).
%base(before_last_cell(Cell)) :-
%    rich_ui(last_cell) &
%    valid_cell(Cell).

init(cell(StartPosition, situation(army(of(Player), count(1)), on(field, owned_by(Player))))) :-
    start_position(Player, StartPosition).
init(Cell) :-
    unify_cell(Cell, cell(Rc, situation(nobody, on(field, wild)))) &
    start_position(_, StartPosition) &
    distinct(StartPosition, Rc).
init(control(red)).

% Random player may throw only as many dice as the largest pawn stack of the current player
% TODO: If all possible moves end-up on the already captured cell, ie no dice roll is needed, then random shouldn't roll dice
legal(random, roll(Dice)) :-
    true(control(Player)) &
    max_possible_pawn_stack(Player, Max) &
    valid_length_dice(Max, Dice).
% Player can move to a neighboring own or not occupied cell with all or less pawns
legal(Player, move(MovingPawns, from(From), to(To))) :-
    true(control(Player)) &
    true(cell(From, situation(army(of(Player), count(StationaryPawns)), _))) &
    le(MovingPawns, StationaryPawns) &
    valid_move(move(MovingPawns, from(From), to(To))) &
    (
        true(cell(To, situation(army(of(Player), _), _))) |
        true(cell(To, situation(nobody, _)))
    ) &
    distinct(From, To).
% A Player can attack a neighboring occupied cell
legal(Player, attack(MovingPawns, from(From), to(To))) :-
    true(control(Player)) &
    true(cell(From, situation(army(of(Player), count(StationaryPawns)), _))) &
    le(MovingPawns, StationaryPawns) &
    valid_move(move(MovingPawns, from(From), to(To))) &
    true(cell(To, situation(army(of(Opponent), _), _))) &
    distinct(From, To) &
    distinct(Player, Opponent).
% It's not legal to move only part of a stack to the same cell as currently standing on
legal(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) :-
    true(control(Player)) &
    true(cell(FromAndTo, situation(army(of(Player), count(MovingPawns)), on(_, wild)))) &
    valid_move(move(MovingPawns, from(FromAndTo), to(FromAndTo))).
% A new pawn can be spawned only if current player doesn't have any pawn left
% and it should be the only choice for a player in such situation
legal(Player, spawn(at(StartPosition))) :-
    player(Player) &
    true(control(Player)) &
    start_position(Player, StartPosition) &
    ~player_has_an_army(Player).
% It's legal for a player to do nothing only if it's not his move
legal(Player, noop) :-
    player(Player) &
    true(control(Q)) &
    distinct(Player, Q).

player_has_an_army(Player) :-
    true(cell(_, situation(army(of(Player), _), _))).

% TODO: goal/2 should succeed only once for any player
goal(random, 0).
goal(Player, Score) :-
    player(Player) &
    player_score(Player, Score).

% Games ends if all board is captured, ie there are no wild cells left
terminal :-
    there_is_no_wild_cells_left(dupa).

% TODO: Game ends if an opposite side of a board is captured
%terminal :-
%    player(red) &
%    cell(rc(3,3), captured_by(red), _).

% There is no hidden state
sees(Role, did(OtherRole, Move)) :-
    role(Role) & 
    does(OtherRole, Move).

% If a player choses to recapture the cell that he is already standing on, then just proceed by the rules
next(cell(FromAndTo, NewSituation)) :-
    does(random, roll(D)) &
    does(_, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldSituation)) &
    type_list_length_prefix(valid_die, D, MovingPawns, ActiveDice) &
    multi_throw_situation(ActiveDice, OldSituation, NewSituation).

% If a cell already contains a players pawn, then a sum must be calculated
next(cell(To, NewSituation)) :-
    does(random, roll(D)) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, situation(army(of(Player), count(StationaryPawns)), On))) &
    saturated_add(StationaryPawns, MovingPawns, NewPawns) &
    type_list_length_prefix(valid_die, D, NewPawns, ActiveDice) &
    multi_throw_situation(ActiveDice, situation(army(of(Player), count(NewPawns)), On), NewSituation).

% Destination is captured by player according to rule book and all pawns appear there, if a cell doesn't have any pawn
next(cell(To, NewSituation)) :-
    does(random, roll(D)) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, situation(nobody, On))) &
    type_list_length_prefix(valid_die, D, MovingPawns, ActiveDice) &
    multi_throw_situation(ActiveDice, situation(army(of(Player), count(MovingPawns)), On), NewSituation).

% Origin retains its capture state and moved pawns are removed
next(cell(From, NewSituation)) :-
    does(_, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(From, situation(army(Of, count(OldPawns)), On))) &
    add(NewPawns, MovingPawns, OldPawns) &
    le(1, NewPawns) &
    unify_situation(NewSituation, situation(army(Of, count(NewPawns)), On)).

next(cell(From, NewSituation)) :-
    does(_, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(From, situation(army(_, count(OldPawns)), On))) &
    add(0, MovingPawns, OldPawns) &
    unify_situation(NewSituation, situation(nobody, On)).

% All other cells should retains their respective state
next(cell(Rc, Situation)) :-
    does(_, move(_, from(From), to(To))) &
    true(cell(Rc, Situation)) &
    distinct(Rc, From) &
    distinct(Rc, To) &
    valid_situation(Situation).

%next(cell(To, NewSituation)) :-
%    does(Player, attack(MovingPawns, from(From), to(To))) &
%    does(random, dice(attacker(AttackerDice), defender(DefenderDice))).

% All other cells should retains their respective state
next(cell(Rc, Situation)) :-
    does(_, spawn(at(Spawn))) &
    true(cell(Rc, Situation)) &
    distinct(Rc, Spawn) &
    valid_situation(Situation).

next(cell(Spawn, situation(army(of(Player), count(NewCount)), On))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, situation(army(of(Player), count(OldCount)), On))) &
    add(1, OldCount, NewCount).

next(cell(Spawn, situation(army(of(Player), count(1)), On))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, situation(nobody, On))).

next(control(P)) :-
    true(control(Q)) &
    player_next(Q, P).

%% TODO: Add outcome to the last_roll state
%next(last_roll(Dice)) :-
%    rich_ui(last_roll) &
%    does(random, roll(Dice)).
%
%next(last_move(Player, Move)) :-
%    rich_ui(last_move) &
%    player(Player) &
%    does(Player, Move).
%
%next(last_cell(Cell)) :-
%    rich_ui(last_cell) &
%    does(_, move(_, _, to(To))) &
%    unify_cell(Cell, cell(To, _)) &
%    true(Cell).
%
%next(before_last_move(Player, Move)) :-
%    rich_ui(last_move) &
%    true(last_move(Player, Move)).
%
%next(before_last_roll(Dice)) :-
%    rich_ui(last_roll) &
%    true(last_roll(Dice)).
%
%next(before_last_cell(Cell)) :-
%    rich_ui(last_cell) &
%    true(last_cell(Cell)).

% Input utils
% TODO: Properly calculate score for multiplayer games
player_score(Player, Score) :-
%   fast_player_score(Player, Score).
    detailed_player_score(Player, Score).

fast_player_score(Player, 100) :-
    player(Player) &
    there_is_no_wild_cells_left(dupa).
fast_player_score(Player, 0) :-
    player(Player) &
    there_is_a_wild_cell(dupa).

there_is_no_wild_cells_left(dupa):-
    ~there_is_a_wild_cell(dupa).
there_is_a_wild_cell(dupa) :-
    true(cell(_, situation(_, on(_, wild)))).

detailed_player_score(Player, 100) :-
    player(Player) &
    there_is_no_wild_cells_left(dupa).
detailed_player_score(Player, Score) :-
    player(Player) &
    there_is_a_wild_cell(dupa) &
    max_pawn_stack(Player, MaxPawnStack) &
    number_of_cells_with_ownership(NumberOfCapturedCells, owned_by(Player)) &
    saturated_add(MaxPawnStack, NumberOfCapturedCells, Score).

number_of_cells_with_ownership(N, Ownership) :-
    list_of_cells_with_particular_ownership(Ownership, RcList) &
    valid_length_rc(N, RcList).

list_of_cells_with_particular_ownership(Ownership, RcList) :-
   det_ownership_cell_list_acc(Ownership, RcList, []).
%   fast_ownership_cell_list_acc(Ownership, RcList, []).

det_ownership_cell_list_acc(Ownership, [], Collected) :-
    valid_ownerhip(Ownership) &
    valid_length_rc(_, Collected) &
   ~there_is_a_different_cell_with_ownership(Ownership, Collected).
det_ownership_cell_list_acc(Ownership, RcList, Collected) :-
    true(cell(H, situation(_, on(_, Ownership)))) &
    type_list_head_tail(valid_rc, NewCollection, H, Collected) &
    ~type_member_list(valid_rc, H, Collected) &
    sorted_without_repetitions(valid_rc, NewCollection) &
    det_ownership_cell_list_acc(Ownership, T, NewCollection) &
    type_list_head_tail(valid_rc, RcList, H, T).
there_is_a_different_cell_with_ownership(Ownership, L) :-
    true(cell(Rc, situation(_, on(_, Ownership)))) &
    valid_length_rc(_, L) &
    ~type_member_list(valid_rc, Rc, L).

% WARNING: Only first answer sould count
fast_ownership_cell_list_acc(Ownership, RcList, Acc) :-
    true(cell(H, situation(_, on(_, Ownership)))) &
    type_list_head_tail(valid_rc, NewAcc, H, Acc) &
    ~type_member_list(valid_rc, H, Acc) &
    fast_ownership_cell_list_acc(Ownership, T, NewAcc) &
    type_list_head_tail(valid_rc, RcList, H, T).
fast_ownership_cell_list_acc(Ownership, [], Acc) :-
    valid_ownerhip(Ownership) &
    valid_length_rc(_, Acc).

% TODO: max_pawn_stack/2 should succeed only once
max_pawn_stack(Player, MaxPawnStack) :-
    true(cell(_, situation(army(of(Player), count(MaxPawnStack)), _))) &
    ~there_are_stacks_larger_than_the_given_one(Player, MaxPawnStack).
max_pawn_stack(Player, 0) :-
    player(Player) &
    ~there_is_a_cell_occupied_by_player(Player).
there_are_stacks_larger_than_the_given_one(Player, MaxPawnStack) :-
    lt(MaxPawnStack, N) &
    true(cell(_, situation(army(of(Player), count(N)), _))).
% TODO: max_possible_pawn_stack/2 should succeed only once
max_possible_pawn_stack(Player, MaxPossiblePawnStack) :-
    possible_pawn_stack(Player, MaxPossiblePawnStack) &
    ~there_are_possible_stacks_larger_than_the_given_one(Player, MaxPossiblePawnStack).
max_possible_pawn_stack(Player, 0) :-
    player(Player) &
    ~there_is_a_cell_occupied_by_player(Player).
there_are_possible_stacks_larger_than_the_given_one(Player, MaxPossiblePawnStack) :-
    player(Player) &
    lt(MaxPossiblePawnStack, N) &
    possible_pawn_stack(Player, N).
possible_pawn_stack(Player, PossiblePawnStack) :-
    true(cell(From, situation(army(of(Player), count(M)), _))) &
    valid_move(move(M, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, situation(army(of(Player), count(N)), _))) &
    saturated_add(M, N, PossiblePawnStack).
possible_pawn_stack(Player, PossiblePawnStack) :-
    true(cell(_, situation(army(of(Player), count(PossiblePawnStack)), _))).

there_is_a_cell_occupied_by_player(Player) :-
    true(cell(_, situation(army(of(Player), _), _))).

% Utils with complete definitions
neighboring_rc(A, B) :-
    valid_rc(A) &
    valid_rc(B) &
    neighboring_rc_aux(A, B).
neighboring_rc_aux(rc(R,C), rc(R,C)) :- num(R) & num(C).
neighboring_rc_aux(rc(R,Lc), rc(R,Rc)) :- num(R) & add(1, Lc, Rc).
neighboring_rc_aux(rc(R,Lc), rc(R,Rc)) :- num(R) & add(1, Rc, Lc).
neighboring_rc_aux(rc(Lr,C), rc(Rr,C)) :- num(C) & add(1, Lr, Rr).
neighboring_rc_aux(rc(Lr,C), rc(Rr,C)) :- num(C) & add(1, Rr, Lr).

multi_throw_situation([], S, S) :-
    unify_situation(S, situation(army(of(_), count(X)), _)) &
    le(1, X).
multi_throw_situation([], S, S) :-
    unify_situation(S, situation(nobody, _)).
multi_throw_situation(Dice, Before, After) :-
    type_list_head_tail(valid_die, Dice, Die, T) &
    single_throw_situation(Die, Before, Next) &
    multi_throw_situation(T, Next, After) &
    valid_situation(After).
single_throw_situation(Die, Before, Next) :-
    outcome_for_single_throw(Die, Before, Outcome) &
    applied_outcome(Outcome, Before, Next).
outcome_for_single_throw(Die, Before, Outcome) :-
    situation_rules(Before, L) &
    nth_element(valid_outcome, Die, L, Outcome).

situation_rules(S, L) :-
    unify_situation(S, situation(army(of(P), count(X)), on(Tile, owned_by(P)))) &
    distinct(X, 0) &
    rules(own, Tile, L).
situation_rules(S, L) :-
    unify_situation(S, situation(army(of(_), count(X)), on(Tile, wild))) &
    distinct(X, 0) &
    rules(wild, Tile, L).
situation_rules(S, L) :-
    unify_situation(S, situation(army(of(P), count(X)), on(Tile, owned_by(Q)))) &
    distinct(X, 0) &
    distinct(P, Q) &
    rules(foreign, Tile, L).

applied_outcome(minus(N), Before, After) :-
    unify_situation(Before, situation(army(Of, count(B)), On)) &
    le(1, N) &
    saturated_sub(B, N, A) &
    le(1, A) &
    unify_situation(After, situation(army(Of, count(A)), On)).
applied_outcome(minus(N), Before, situation(nobody, On)) :-
    unify_situation(Before, situation(army(_, count(B)), On)) &
    le(1, N) &
    saturated_sub(B, N, A) &
    eq(0, A).
applied_outcome(plus(N), Before, After) :-
    unify_situation(Before, situation(army(Of, count(B)), On)) &
    le(1, N) &
    saturated_add(N, B, A) &
    unify_situation(After, situation(army(Of, count(A)), On)).
applied_outcome(nothing, Before, After) :-
    unify_situation(Before, After).
applied_outcome(capture, Before, After) :-
    (
        unify_situation(Before, situation(army(of(P), Count), on(Tile, wild))) |
        (
            unify_situation(Before, situation(army(of(P), Count), on(Tile, owned_by(Q)))) &
            distinct(P, Q)
        )
    ) &
    unify_situation(After, situation(army(of(P), Count), on(Tile, owned_by(P)))).

% Unification predicates
unify_situation(A, A) :- valid_situation(A).
unify_die(A, A) :- valid_die(A).
unify_cell(A, A) :- valid_cell(A).

% Validation predicates
valid_outcome(capture).
valid_outcome(nothing).
valid_outcome(minus(N)) :- le(1, N).
valid_outcome(plus(N)) :- le(1, N).

valid_tile(field).
%valid_tile(town).
%valid_tile(garrison).
%valid_tile(fort).

valid_situation(situation(Occupation, on(Tile,  Ownership))) :-
    valid_occupation(Occupation) &
    valid_tile(Tile) &
    valid_ownerhip(Ownership).

valid_ownerhip(wild).
valid_ownerhip(owned_by(Player)) :-
    player(Player).

valid_occupation(nobody).
valid_occupation(army(of(Player), count(X))) :-
    player(Player) &
    num(X).

%valid_situation_non_0(Situation) :-
%    unify_situation(Situation, situation(nobody, _)).
%valid_situation_non_0(Situation) :-
%    unify_situation(Situation, situation(army(_, count(X)), _)) &
%    le(1, X).

valid_cell(cell(Coordinates, Situation)) :-
    valid_rc(Coordinates) &
    valid_situation(Situation).

valid_row(I) :-
    max_row(MaxRow) &
    le(1, I) & le(I, MaxRow).

valid_col(I) :-
    max_col(MaxCol) &
    le(1, I) & le(I, MaxCol).

valid_rc(rc(Row, Column)) :-
    valid_row(Row) &
    valid_col(Column).

valid_die(1).
valid_die(2).
valid_die(3).
valid_die(4).
%valid_die(5).
%valid_die(6).
valid_dice(L) :-
    type_nl(valid_die, nl(_, L)).
valid_length_dice(Number, Dice) :-
    type_nl(valid_die, nl(Number, Dice)).
valid_length_rc(Number, RcList) :-
    type_nl(valid_rc, nl(Number, RcList)).

valid_move(move(NumberOfPawns, from(From), to(To))) :-
    le(1, NumberOfPawns) &
    neighboring_rc(From, To).

% List utils
type(valid_outcome).
type(valid_die).
type(valid_rc).
%type(num).
type_element(valid_rc, Element) :- valid_rc(Element).
type_element(valid_outcome, Element) :- valid_outcome(Element).
type_element(valid_die, Element) :- valid_die(Element).
%type_element(num, Element) :- num(Element).

% TODO: Optimize list implementation
type_nl_00(Tp, []) :- type(Tp).
type_nl_01(Tp, [H]) :- type_element(Tp, H) & type_nl_00(Tp, []).
type_nl_02(Tp, [H,T1]) :- type_element(Tp, H) & type_nl_01(Tp, [T1]).
type_nl_03(Tp, [H,T1,T2]) :- type_element(Tp, H) & type_nl_02(Tp, [T1,T2]).
type_nl_04(Tp, [H,T1,T2,T3]) :- type_element(Tp, H) & type_nl_03(Tp, [T1,T2,T3]).
%type_nl_05(Tp, [H,T1,T2,T3,T4]) :- type_element(Tp, H) & type_nl_04(Tp, [T1,T2,T3,T4]).
%type_nl_06(Tp, [H,T1,T2,T3,T4,T5]) :- type_element(Tp, H) & type_nl_05(Tp, [T1,T2,T3,T4,T5]).
%type_nl_07(Tp, [H,T1,T2,T3,T4,T5,T6]) :- type_element(Tp, H) & type_nl_06(Tp, [T1,T2,T3,T4,T5,T6]).
%type_nl_08(Tp, [H,T1,T2,T3,T4,T5,T6,T7]) :- type_element(Tp, H) & type_nl_07(Tp, [T1,T2,T3,T4,T5,T6,T7]).
%type_nl_09(Tp, [H,T1,T2,T3,T4,T5,T6,T7,T8]) :- type_element(Tp, H) & type_nl_08(Tp, [T1,T2,T3,T4,T5,T6,T7,T8]).
%type_nl_10(Tp, [H,T1,T2,T3,T4,T5,T6,T7,T8,T9]) :- type_element(Tp, H) & type_nl_09(Tp, [T1,T2,T3,T4,T5,T6,T7,T8,T9]).
type_nl(Tp, nl( 0, [])) :- type_nl_00(Tp, []).
type_nl(Tp, nl( 1, [H])) :- type_nl_01(Tp, [H]).
type_nl(Tp, nl( 2, [H,T1])) :- type_nl_02(Tp, [H,T1]).
type_nl(Tp, nl( 3, [H,T1,T2])) :- type_nl_03(Tp, [H,T1,T2]).
type_nl(Tp, nl( 4, [H,T1,T2,T3])) :- type_nl_04(Tp, [H,T1,T2,T3]).
%type_nl(Tp, nl( 5, [H,T1,T2,T3,T4])) :- type_nl_05(Tp, [H,T1,T2,T3,T4]).
%type_nl(Tp, nl( 6, [H,T1,T2,T3,T4,T5])) :- type_nl_06(Tp, [H,T1,T2,T3,T4,T5]).
%type_nl(Tp, nl( 7, [H,T1,T2,T3,T4,T5,T6])) :- type_nl_07(Tp, [H,T1,T2,T3,T4,T5,T6]).
%type_nl(Tp, nl( 8, [H,T1,T2,T3,T4,T5,T6,T7])) :- type_nl_08(Tp, [H,T1,T2,T3,T4,T5,T6,T7]).
%type_nl(Tp, nl( 9, [H,T1,T2,T3,T4,T5,T6,T7,T8])) :- type_nl_09(Tp, [H,T1,T2,T3,T4,T5,T6,T7,T8]).
%type_nl(Tp, nl(10, [H,T1,T2,T3,T4,T5,T6,T7,T8,T9])) :- type_nl_10(Tp, [H,T1,T2,T3,T4,T5,T6,T7,T8,T9]).
type_list_head_tail(Tp, H!T,  H, T) :- type_nl(Tp, nl(_,  H!T )).
%type_list_head_tail(Tp, [H|T], H, T) :- type_nl(Tp, nl(_, [H|T])).

nth_element(Tp, 1, L, H) :-
    type_list_head_tail(Tp, L, H, _).
nth_element(Tp, N, L, E) :-
    type_list_head_tail(Tp, L, _, T) &
    type_element(Tp, E) &
    add(1, M, N) &
    nth_element(Tp, M, T, E).

type_member_list(Tp, E, L) :-
    type_list_head_tail(Tp, L, E, _).
type_member_list(Tp, E, L) :-
    type_list_head_tail(Tp, L, _, T) &
    type_member_list(Tp, E, T) &
    type_element(Tp, E).

sorted_without_repetitions(Tp, []) :- type(Tp).
sorted_without_repetitions(Tp, [E]) :- type_element(Tp, E).
%sorted_without_repetitions(Tp, [H1,H2|T]) :-
sorted_without_repetitions(Tp, H1!(H2!T)) :-
    type_lt(Tp, H1, H2) &
    sorted_without_repetitions(Tp, L) &
    type_list_head_tail(Tp, L, H2, T).

type_lt(valid_rc, E1, E2) :- rc_lt(E1, E2).

rc_lt(Rc1, Rc2) :-
    rank(Rc1, Rank1) &
    rank(Rc2, Rank2) &
    lt(Rank1, Rank2).

% Cell ordering:
%
%   r\c| 1  2  3  4  5
%    --+---------------
%    1 | 0  1  4  9 16
%    2 | 3  2  5 10 17
%    3 | 8  7  6 11 18
%    4 |15 14 13 12 19
%    5 |24 23 22 21 20
%
rank(rc(1, 1),  0).
rank(rc(1, 2),  1).
rank(rc(1, 3),  4).
%rank(rc(1, 4),  9).
%rank(rc(1, 5), 16).
rank(rc(2, 1),  3).
rank(rc(2, 2),  2).
rank(rc(2, 3),  5).
%rank(rc(2, 4), 10).
%rank(rc(2, 5), 17).
rank(rc(3, 1),  8).
rank(rc(3, 2),  7).
rank(rc(3, 3),  6).
%rank(rc(3, 4), 11).
%rank(rc(3, 5), 18).
%rank(rc(4, 1), 15).
%rank(rc(4, 2), 14).
%rank(rc(4, 3), 13).
%rank(rc(4, 4), 12).
%rank(rc(4, 5), 19).
%rank(rc(5, 1), 24).
%rank(rc(5, 2), 23).
%rank(rc(5, 3), 22).
%rank(rc(5, 4), 21).
%rank(rc(5, 5), 20).

type_list_length_prefix(Tp, L, 0, []) :- type_nl(Tp, nl(_, L)).
type_list_length_prefix(Tp, L, N, S) :-
    add(1, M, N) &
    type_list_length_prefix(Tp, Lt, M, St) &
    type_list_head_tail(Tp, L, H, Lt) &
    type_list_head_tail(Tp, S, H, St).

%% Numeric list utils
%num_list_head_tail(List, H, T) :-
%    type_list_head_tail(num, List, H, T).
%max_element([Max], Max).
%max_element(L, Max) :-
%    num_list_head_tail(L, H, T) &
%    max_element(T, OldMax) &
%    maximum(H, OldMax, Max).

% Saturation arithmetic utils
%
% Subtraction, interestingly enough, isn't an inverse of addtion (and vice
% versa) in saturation arithmetic. It is better to think of it as a completely
% different operation. I propose to call an inverse of addtion an anti-addtion
% (â¨¤) and an inverse of subtraction an anti-subtraction (Ìƒâˆ’). Also it should be
% noted that those anti-operations are proper relations and they aren't
% functions.
%
% Consider this example (saturation bounds [0, 4]):
%   2 + 3 = 4
% Subtraction will yield following values:
%   4 âˆ’ 3 = 1
%   4 âˆ’ 2 = 2
% Anti-addition will produce a set:
%   4 â¨¤ 3 = {1, 2, 3, 4}
%   4 â¨¤ 2 = {2, 3, 4}

saturated_add(A, B, C) :- saturated_add_ns(ns(A, _), ns(B, _), ns(C, _)).
saturated_sub(A, B, C) :- saturated_sub_ns(ns(A, _), ns(B, _), ns(C, _)).

saturated_add_ns(ns(0, 0), B, B) :-
    ns_val(B).
saturated_add_ns(A, B, C) :-
    ns_suc(Am1, A) &
    ns_suc(B, Bp1) &
    saturated_add_ns(Am1, Bp1, C) &
    ns_val(C).
saturated_add_ns(A, B, B) :-
    ns_suc(_, A) &
    ns_val(B) &
    ~saturated_add_ns_aux(B).
saturated_add_ns_aux(B) :-
    ns_val(Tmp) &
    ns_suc(B, Tmp).

saturated_sub_ns(A, ns(0, 0), A) :-
    ns_val(A).
saturated_sub_ns(A, B, C) :-
    ns_suc(Bm1, B) &
    ns_suc(Am1, A) &
    saturated_sub_ns(Am1, Bm1, C) &
    ns_val(C).
saturated_sub_ns(A, B, ns(0, 0)) :-
    ns_suc(_, B) &
    ns_val(A) &
    ~saturated_sub_ns_aux(A).
saturated_sub_ns_aux(A) :-
    ns_val(Tmp) &
    ns_suc(Tmp, A).

% Arithmetic utils
num(A) :- ns_val(ns(A, _)).
eq(A, A) :- ns_eq(ns(A, S), ns(A, S)).
le(A, B) :- ns_le(ns(A, _), ns(B, _)).
lt(A, B) :- ns_lt(ns(A, _), ns(B, _)).
add(A, B, C) :- ns_add(ns(A, _), ns(B, _), ns(C, _)).
%mul(A, B, C) :- ns_mul(ns(A, _), ns(B, _), ns(C, _)).
%pow(A, B, C) :- ns_pow(ns(A, _), ns(B, _), ns(C, _)).
%maximum(A, B, A) :- lt(B, A).
%maximum(A, B, B) :- le(A, B).

%ns_pow(ns(An, succ(S)), ns(0, 0), ns(1, succ(0))) :-
%    ns_val(ns(An, succ(S))).
%ns_pow(A, B, C) :-
%    ns_suc(Bm1, B) &
%    ns_pow(A, Bm1, Part) &
%    ns_mul(Part, A, C).
%ns_mul(ns(0, 0), B, ns(0, 0)) :-
%    ns_val(B).
%ns_mul(A, B, C) :-
%    ns_suc(Am1, A) &
%    ns_mul(Am1, B, Part) &
%    ns_add(B, Part, C).
ns_add(ns(0, 0), B, B) :-
    ns_val(B).
ns_add(A, B, C) :-
    ns_suc(Am1, A) &
    ns_add(Am1, B, X) &
    ns_suc(X, C) &
    ns_val(B).
ns_suc(ns(An, As), ns(Bn, succ(As))) :-
    ns_val(ns(An, As)) &
    ns_val(ns(Bn, succ(As))).
ns_le(A, A) :-
    ns_val(A).
ns_le(A, B) :-
    ns_suc(X, B) &
    ns_le(A, X) &
    ns_val(A).
ns_eq(A, A) :-
    ns_val(A).
ns_lt(A, B) :-
    ns_suc(X, B) &
    ns_le(A, X).

% TODO: Is it possible to define somethin similar in GDL?
%eval(A + B = C) :-
%    add(A, B, C).

ns_val(ns( 0, 0)).
ns_val(ns( 1, succ(0))).
ns_val(ns( 2, succ(succ(0)))).
ns_val(ns( 3, succ(succ(succ(0))))).
ns_val(ns( 4, succ(succ(succ(succ(0)))))).
%ns_val(ns( 5, succ(succ(succ(succ(succ(0))))))).
%ns_val(ns( 6, succ(succ(succ(succ(succ(succ(0)))))))).
%ns_val(ns( 7, succ(succ(succ(succ(succ(succ(succ(0))))))))).
%ns_val(ns( 8, succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))).
%ns_val(ns( 9, succ(succ(succ(succ(succ(succ(succ(succ(succ(0))))))))))).
%ns_val(ns(10, succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))))).

% Prolog code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Arithmetic tests
all_arithmetics_tests_are_passing :-
    saturated_addition_holds_for_all_inputs,
    saturated_subtraction_holds_for_all_inputs,
    intersection_of_saturated_addtion_and_saturated_subtraction_is_always_a_regular_addition,
    all_arithmetic_predicates_always_halt,
    all_numbers_are_legal,
    all_le_tests,
    all_summation_tests.

intersection_of_saturated_addtion_and_saturated_subtraction_is_always_a_regular_addition :-
    \+there_is_a_combination_of_numbers_for_which_intersection_of_saturated_addtion_and_saturated_subtraction_isnt_a_regular_addition(_).
there_is_a_combination_of_numbers_for_which_intersection_of_saturated_addtion_and_saturated_subtraction_isnt_a_regular_addition(A+B=C) :-
    saturated_add(A, B, C),
    saturated_sub(C, B, A),
    \+add(A, B, C).

saturated_subtraction_holds_for_all_inputs :-
    \+there_is_an_input_for_which_saturated_subtraction_doesnt_hold(_).
there_is_an_input_for_which_saturated_subtraction_doesnt_hold(A+B) :-
    num(A),
    num(B),
    \+saturated_sub(A, B, _).

saturated_addition_holds_for_all_inputs :-
    \+there_is_an_input_for_which_saturated_addition_doesnt_hold(_).
there_is_an_input_for_which_saturated_addition_doesnt_hold(A-B) :-
    num(A),
    num(B),
    \+saturated_add(A, B, _).

all_numbers_are_legal :-
    \+val_generates_illegal_number(_).
val_generates_illegal_number(N) :-
    num(N), \+integer(N).

all_le_tests :-
    \+le_test_1(_,_),
    \+given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(_,_,_),
    \+there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(_,_).
le_test_1(A, B) :-
    le(A, B), le(B, A), A \= B.
given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(A, B, X) :-
    le(A, B), A \= B, le(X, A), le(B, X).
there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(A, X) :-
    le(X, A), le(A, X), A \= X.

all_summation_tests :-
    example_1_plus_2_equals_3,
    example_1_plus_2_is_never_equal_to_any_number_other_than_3,
    sum_of_2_non_0_numbers_is_never_less_then_any_of_summands.
example_1_plus_2_equals_3 :-
    add(1, 2, 3).
example_1_plus_2_is_never_equal_to_any_number_other_than_3 :-
    \+example_1_plus_2_is_equal_to_a_number_other_than_3(_).
example_1_plus_2_is_equal_to_a_number_other_than_3(C) :-
    add(1, 2, C), C \= 3.
sum_of_2_non_0_numbers_is_never_less_then_any_of_summands :-
    \+sum_of_2_non_0_numbers_is_less_then_any_of_summands(_,_,_).
sum_of_2_non_0_numbers_is_less_then_any_of_summands(A,B,C) :-
    add(A, B, C),
    A \= 0,
    B \= 0,
    (
        le(C, A);
        le(C, A)
    ).

all_arithmetic_predicates_always_halt :-
    always_halts(num(_)),
    always_halts(eq(_, _)),
    always_halts(le(_, _)),
    always_halts(lt(_, _)),
    always_halts(saturated_add(_,_,_)),
    always_halts(saturated_sub(_,_,_)),
    always_halts(add(_, _, _)),
   *always_halts(mul(_, _, _)),
   *always_halts(pow(_, _, _)).

% Test for operations on lists
all_lists_tests_are_passing :-
     % Test is disabled. It is expensive to check ALL possible dice lists.
    *all_list_prefixes_conform_to_the_reference_implementation.

all_list_prefixes_conform_to_the_reference_implementation :-
    \+there_is_an_invalid_prefix(valid_die, _,_,_).
there_is_an_invalid_prefix(Tp, L, N, S) :-
    type_list_length_prefix(Tp, L, N, S),
    \+reference_type_list_length_prefix(Tp, L, N, S).

reference_type_list_length_prefix(_, L, N, S) :-
    length(S, N),
    prefix(S, L).

% Configuration tests
all_configuration_tests_are_passing :-
   ?there_is_a_strong_correspondence_between_players_and_spawns,
   ?there_is_a_rule_for_each_die,
   ?there_is_a_die_for_each_rule,
   ?all_rules_are_representable_using_valid_list,
  -?all_players_are_ordered.

% TODO: All players form a cycle
all_players_are_ordered :-
    \+tx(_).
tx(P) :-
    player(P),
    (
        \+player_next(_, P);
        \+player_next(P, _)
    ).

there_is_a_strong_correspondence_between_players_and_spawns :-
    \+there_is_a_starting_position_without_a_player(_),
    \+there_is_a_player_without_starting_position(_).
there_is_a_starting_position_without_a_player(Spawn) :-
    start_position(P, Spawn),
    \+player(P).
there_is_a_player_without_starting_position(P) :-
    player(P),
    \+start_position(P, _).

there_is_a_rule_for_each_die :-
    \+there_is_a_die_without_associated_rule(_).
there_is_a_die_for_each_rule :-
    \+there_is_a_rule_without_associated_die(_, _).
there_is_a_die_without_associated_rule(D) :-
    valid_die(D),
    rules(_, _, L),
    \+nth_element(valid_outcome, D, L, _).
there_is_a_rule_without_associated_die(rule(Ownership, Tile, L), nth(D, O)) :-
    rules(Ownership, Tile, L),
    nth_element(valid_outcome, D, L, O),
    \+valid_die(D).

all_rules_are_representable_using_valid_list :-
    \+there_is_a_rule_which_isnt_representable_using_valid_list(_).
there_is_a_rule_which_isnt_representable_using_valid_list(rule(Ownership, Tile, L)) :-
    rules(Ownership, Tile, L),
    \+type_nl(valid_outcome, nl(_, L)).

% Input tests
all_input_tests_are_passing :-
    no_player_can_move_0_pawns,
    only_random_role_can_roll_dice,
    player_can_move_to_neighboring_cell_only.

player_can_move_to_neighboring_cell_only :-
    \+there_is_a_move_to_a_distant_cell(_,_).
there_is_a_move_to_a_distant_cell(Role, Move) :-
    role(Role),
    Move = move(_, from(A), to(B)),
    input(Role, Move),
    \+neighboring_rc(A, B).
only_random_role_can_roll_dice :-
    \+there_is_different_from_random_role_that_can_roll_dice(_).
there_is_different_from_random_role_that_can_roll_dice(R) :-
    role(R), input(R, roll(_)), R \= random.

no_player_can_move_0_pawns :-
    \+player_can_move_0_pawns(_).
player_can_move_0_pawns(P) :-
    player(P),
    input(P, move(0, _)).

% Rules tests
% TODO: Perform tests for all possible board configurations
valid_board_configuration :-
    asserta.

% TODO: All players have at least 1 legal move in current non-terminal state
all_statements_about_current_configuration_are_valid :-
    \+invalid_statement_for_current_configuration_exists(_).
invalid_statement_for_current_configuration_exists(I) :-
    true(I),
    \+base(I).

max_possible_pawn_stack_is_ok_for_the_current_configuration :-
    \+there_is_a_discrepancy_for_max_possible_pawn_stack_predicate_with_a_reference_implementation(_,_,_).
there_is_a_discrepancy_for_max_possible_pawn_stack_predicate_with_a_reference_implementation(Player, MaxPawnStack, ReferenceMaxPawnStack) :-
    max_possible_pawn_stack(Player, MaxPawnStack),
    reference_max_possible_pawn_stack(Player, ReferenceMaxPawnStack),
    MaxPawnStack \= ReferenceMaxPawnStack.

max_pawn_stack_is_ok_for_the_current_configuration :-
    \+there_is_a_discrepancy_for_max_pawn_stack_predicate_with_a_reference_implementation(_,_,_).
there_is_a_discrepancy_for_max_pawn_stack_predicate_with_a_reference_implementation(Player, MaxPawnStack, ReferenceMaxPawnStack) :-
    max_pawn_stack(Player, MaxPawnStack),
    reference_max_pawn_stack(Player, ReferenceMaxPawnStack),
    MaxPawnStack \= ReferenceMaxPawnStack.

reference_max_pawn_stack(Player, Max) :-
    findall(N, true(cell(_, situation(army(of(Player), count(N)), _))), L),
    max_list_element(L, Max).

reference_max_possible_pawn_stack(Player, Max) :-
    findall(N, possible_pawn_stack(Player, N), Army),
    max_list_element(Army, Max).

all_legal_moves_for_current_configuration_are_valid :-
    \+invalid_but_legal_move_for_current_configuration_exists(_, _).
invalid_but_legal_move_for_current_configuration_exists(Role, Move) :-
    legal(Role, Move),
    \+input(Role, Move).

all_player_score_tests_are_passing :-
   ?all_roles_have_a_score_for_current_configuration,
   ?all_scores_are_unambiguous_for_current_configuration,
   ?detailed_player_score_gives_same_results_as_a_reference_implementation.

detailed_player_score_gives_same_results_as_a_reference_implementation :-
    \+t1(_,_),
    \+t2(_,_).
t1(Player, Score) :-
    player(Player),
    detailed_player_score(Player, Score),
    \+reference_detailed_player_score(Player, Score).
t2(Player, Score) :-
    player(Player),
    reference_detailed_player_score(Player, Score),
    \+detailed_player_score(Player, Score).

reference_detailed_player_score(Player, Score) :-
    findall(Rc, (true(cell(Rc, situation(_, on(_, owned_by(Player)))))), L),
    length(L, NumberOfCapturedCells),
    reference_max_pawn_stack(Player, MaxPawnStack),
    Score is NumberOfCapturedCells + MaxPawnStack.

all_roles_have_a_score_for_current_configuration :-
    \+there_is_a_role_without_a_score_for_current_configuration(_).
there_is_a_role_without_a_score_for_current_configuration(Role) :-
    role(Role),
    \+goal(Role, _).

all_scores_are_unambiguous_for_current_configuration :-
    \+there_is_a_role_with_ambiguous_score(_).
there_is_a_role_with_ambiguous_score(Role) :-
    role(Role),
    \+role_scores_are_unambiguous(Role).
role_scores_are_unambiguous(Role) :-
    findall(Score, (goal(Role, Score)), AllScores),
    list_of_identical_values(AllScores).

current_state_is_not_terminal :-
    \+terminal.

% TODO: Why disabled test case is failing?
all_rules_tests_are_passing :-
   ?rules_should_terminate_if_count_is_set_but_dice_list_is_not,
   ?rules_should_terminate_if_dice_list_is_set_but_count_is_not,
   ?count_zero_doesnt_leak,
   *all_rules([4,4,1,1], situation(army(of(red), count(4)), on(field, wild)), [situation(army(of(red), count(2)), on(field,wild))]),
   *all_rules([2,1,1,3], situation(army(of(red), count(4)), on(field, wild)), [situation(army(of(red), count(2)), on(field,owned_by(red)))]),
   ?all_rules([1,2,3,4], situation(army(of(red), count(4)), on(field, wild)), [situation(army(of(red), count(3)), on(field,owned_by(red)))]),
   ?all_rules([1], situation(army(of(red), count(1)), on(field, owned_by(red))), [situation(army(of(red), count(1)), on(field,owned_by(red)))]),
   ?all_rules([1,1], situation(army(of(red), count(2)), on(field, wild)), [situation(nobody, on(field, wild))]),
   *all_rules([1,1,1], situation(army(of(red), count(2)), on(field, wild)), [situation(nobody, on(field, wild))]),
   *all_rules([6,6,6,6,6,6], situation(army(of(red),count(6)),on(field,wild)), [situation(army(of(red),count(6)),on(field,wild))]).

count_zero_doesnt_leak :-
    \+count_zero_leaks_out(_,_,_).
count_zero_leaks_out(Dice, Before, After) :-
    player(Player),
    list_up_to(2, Dice),
    After = situation(army(of(Player), count(0)), _),
    multi_throw_situation(Dice, Before, After).

rules_should_terminate_if_count_is_set_but_dice_list_is_not :-
    always_halts(multi_throw_situation([_,_,_], situation(army(of(red), count(1)), on(field, wild)), _)).
rules_should_terminate_if_dice_list_is_set_but_count_is_not :-
    always_halts(multi_throw_situation([], Before, _)),
    always_halts(multi_throw_situation([1], Before, _)).

all_rules(Dice, Before, AllPossibleOutcomes) :-
    findall(After, multi_throw_situation(Dice, Before, After), AllPossibleOutcomes).

% FIXME: Those tests require major rework. Right now they can't be executed
% during startup, because they require to call retract/1 on already defined
% predicate true/1.
all_board_tests_are_passing :-
    there_is_a_legal_move_if_more_dice_were_throw_than_pawns.

there_is_a_legal_move_if_more_dice_were_throw_than_pawns :-
    asserta(true(cell(rc(1, 1), situation(nobody,                  on(field, owned_by(red)))))),
    asserta(true(cell(rc(1, 2), situation(nobody,                  on(field, owned_by(red)))))),
    asserta(true(cell(rc(1, 3), situation(army(of(red), count(2)), on(field, owned_by(red)))))),
    asserta(true(cell(rc(2, 1), situation(nobody,                  on(field, owned_by(red)))))),
    asserta(true(cell(rc(2, 2), situation(nobody,                  on(field, wild         ))))),
    asserta(true(cell(rc(2, 3), situation(nobody,                  on(field, owned_by(red)))))),
    asserta(true(cell(rc(3, 1), situation(nobody,                  on(field, wild         ))))),
    asserta(true(cell(rc(3, 2), situation(army(of(red), count(1)), on(field, wild         ))))),
    asserta(true(cell(rc(3, 3), situation(nobody,                  on(field, owned_by(red)))))),
    asserta(true(control(red))),
    asserta(does(random, roll([1,4]))),
    asserta(does(red, move(1, from(rc(3, 2)), to(rc(2, 2))))),
    next(cell(rc(2,2), _)) ->
        clean_up;
        (
            clean_up,
            false
        ).

clean_up :-
    retractall(true(_)),
    retractall(does).

all_tests_are_passing :-
   ?all_configuration_tests_are_passing,
   ?all_statements_about_current_configuration_are_valid,
   ?max_possible_pawn_stack_is_ok_for_the_current_configuration,
   ?max_pawn_stack_is_ok_for_the_current_configuration,
   ?all_legal_moves_for_current_configuration_are_valid,
   ?all_player_score_tests_are_passing,
   ?current_state_is_not_terminal,
   *all_board_tests_are_passing,
   ?all_rules_tests_are_passing,
   ?all_arithmetics_tests_are_passing,
   ?all_lists_tests_are_passing,
   ?all_input_tests_are_passing.

% Test utils
list_up_to(0, []).
list_up_to(N, L) :-
    N > 0,
    (
        (
            length(L, N)
        );
        (
            M is N - 1,
            list_up_to(M, L)
        )
    ).

list_of_identical_values([]).
list_of_identical_values([H|T]) :-
    value_of_all_elements_of_a_list(H, T).
value_of_all_elements_of_a_list(_, []).
value_of_all_elements_of_a_list(H, [H|T]) :-
    value_of_all_elements_of_a_list(H, T).

always_halts(Goal) :-
    \+doesnt_halt(Goal).
doesnt_halt(Goal) :-
    call(Goal), false.

max_list_element([Max], Max).
max_list_element([H|T], Max) :-
    max_list_element(T, PrevMax),
    max_number(H, PrevMax, Max).

max_number(A, B, A) :- A > B.
max_number(A, B, B) :- B >= A.

% Assert that current configuration is initial
true(X) :- init(X).

log_term(Prefix, Term) :-
    write(Prefix) -> write(' : ') -> write(Term) -> nl.
log_term_excpt(Goal, Exception) :-
    log_term(excp, Goal) ->
        write('\t') -> write(Exception) -> nl.

'&'(Lhs, Rhs) :-
    call(Lhs), call(Rhs).
'|'(Lhs, Rhs) :-
    call(Lhs) ; call(Rhs).
'~'(Rhs) :-
    \+ call(Rhs).
'*'(_).

'$'(Goal) :-
    log_term(call, Goal) ->
        $-Goal,
        log_term(exit, Goal).

'$-'(Goal) :-
    catch(
        Goal,
        Exception,
        (
            log_term_excp(Goal, Exception) ->
                throw(Exception)
        )
    ).

'?'(Goal) :-
    call(Goal) ~>
        log_term(fail, Goal) ->
            false.

'-?'(Goal) :-
    call(Goal) ~>
        throw(must_succeed_by_failed(Goal)).

% Operator 'unless'
% FIXME: Don't call Cond twice
'~>'(Cond, IfFailed) :-
    \+call(Cond) ->
        call(IfFailed);
        call(Cond).

% FIXME: It looks like distinct/2 should behave like dif/2
distinct(A, B) :- A \= B.

% Ciao prolog requires main/1 predicate in order to run the script
main(_).

% NOTE: Uncomment following code before running JLog
%catch(G, _, _) :- call(G).
%false :- \+true.

% This file was tested and can be executed directly by the following Prolog systems:
%   GNU Prolog:
%       gprolog --consult-file zxvt.pdb
%   Scryer Prolog:
%       scryer-prolog zxvt.pdb
%   SWI Prolog:
%       swipl -s zxvt.pdb
%   Ciao:
%       ciao run zxvt.pdb
%   Trealla Prolog:
%       tpl zxvt.pdb
%   tuProlog:
%       TODO: tuProlog doesn't have length/2 as a builting predicate, need to find a way to enable it
%       java -jar /opt/tuprolog/2p-repl-0.20.0-redist.jar -T zxvt.pdb
%   B-Prolog:
%       WARNING: Doesn't really work without removing '|'/2 and '$'/2 operators
%       bp "consult('zxvt.pdb')"
%   JLog:
%      java -jar /opt/jlog/1.3.6/JLog.jar
%
%true(cell(rc(1, 1), situation(army(of(red), count(1)), on(field, owned_by(red))))).
%true(cell(rc(1, 3), situation(nobody, on(field, owned_by(red))))).
%true(cell(rc(2, 3), situation(nobody, on(field, owned_by(red))))).
%true(cell(rc(3, 2), situation(nobody, on(field, owned_by(red))))).
%true(cell(rc(3, 3), situation(nobody, on(field, wild)))).
%true(control(red)),
%
% BasesInputsValidator
%     org.ggp.base.validator.ValidatorException:
%         Validator:
%             Could not find legal moves while simulating:
%                 There are no legal moves defined for blue in [
%                     ( true ( control blue ) ),
%                     ( true ( cell ( rc 1 1 ) ( situation nobody ( on field ( owned_by red ) ) ) ) ),
%                     ( true ( cell ( rc 2 1 ) ( situation ( army ( of red ) ( count 2 ) ) ( on field wild ) ) ) ),
%                     ( true ( cell ( rc 2 2 ) ( situation ( army ( of blue ) ( count 1 ) ) ( on field ( owned_by blue ) ) ) ) )
%                 ]
% SimulationValidator
%   org.ggp.base.validator.ValidatorException:
%       Validator:
%           Could not find legal moves while simulating:
%               There are no legal moves defined for blue in [
%                   ( true ( control blue ) ),
%                   ( true ( cell ( rc 1 1 ) ( situation nobody ( on field ( owned_by red ) ) ) ) ),
%                   ( true ( cell ( rc 1 2 ) ( situation ( army ( of red ) ( count 1 ) ) ( on field wild ) ) ) ),
%                   ( true ( cell ( rc 2 1 ) ( situation ( army ( of red ) ( count 1 ) ) ( on field wild ) ) ) ),
%                   ( true ( cell ( rc 2 2 ) ( situation ( army ( of blue ) ( count 1 ) ) ( on field ( owned_by blue ) ) ) ) )
%                   ]
% 
