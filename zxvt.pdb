% Not quite Capture of the Territory
% 1 player
% Board 3Ã—3
% No buildings
% Pawns can't be stacked and only single pawn can be placed on the board
% Goal is to capture the whole board

% WARNING: Remove to get valid program in GDL-II (HRF)
:- op(1000, xfy, '&').
:- op(1100, xfy, '|').
:- op(900, fy, '~').
:- op(950, fy, '*').
:- op(900, fy, '$').
:- op(900, fy, '$-').
:- initialization(all_tests_are_passing).

% Configuration
max_row(3).
max_col(3).
player(red).
start_position(red, rc(1,1)).
rich_ui(no_rich_ui).%Avoid exception if all UI enrichments are disabled
rich_ui(last_roll).
rules(own,     any,      [nothing ,nothing ,nothing ,nothing ,nothing,nothing]).
rules(wild,    field,    [minus(1),nothing ,nothing ,capture ,capture,plus(1)]).
rules(wild,    town,     [minus(1),minus(1),nothing ,capture ,plus(1),plus(1)]).
rules(wild,    garrison, [minus(1),minus(1),minus(1),nothing ,capture,plus(1)]).
rules(wild,    fort,     [minus(1),minus(1),minus(1),capture ,plus(1),plus(1)]).
rules(foreign, field,    [minus(1),minus(1),nothing ,nothing ,capture,capture]).
rules(foreign, town,     [minus(1),minus(1),nothing ,nothing ,nothing,capture]).
rules(foreign, garrison, [minus(1),minus(1),minus(1),nothing ,capture,capture]).
rules(foreign, fort,     [minus(1),minus(1),minus(1),minus(1),nothing,capture]).

% GDL
role(random).
role(red).

% Number of rolled dice shouldn't exceed allowed pawn stack size
input(random, roll(L)) :-
    roll_d6(M, L) &
    stack(M).
input(Player, move(NumberOfPawns, from(From), to(To))) :-
    player(Player) &
    stack(NumberOfPawns) &
    neighboring_coordinates(From, To).
% New pawn can be spawned only at player's starting position
input(Player, spawn(at(StartPosition))) :-
    start_position(Player, StartPosition).

base(Cell) :- valid_cell(Cell).
base(control(R)) :- player(R).
base(last_roll(D6, Outcome)) :-
    rich_ui(last_roll) &
    d6(D6) &
    outcome(Outcome).

init(cell(StartPosition, situation(army(of(Player), count(succ(0))), on(field, owned_by(Player))))) :-
    start_position(Player, StartPosition).
init(cell(Rc, situation(nobody, on(field, wild)))) :-
    valid_cell(cell(Rc, situation(nobody, on(field, wild)))) &
    start_position(_, StartPosition) &
    distinct(StartPosition, Rc).
init(control(red)).

% TODO: Number of dice thrown should be equal to the largest player's pawn stack
legal(random, roll([D])) :-
    true(control(Player)) &
    roll_d6(N, [D]) & ns_val(N, S) &
    true(cell(_, situation(army(of(Player), count(S)), _))).
legal(Player, move(MovingPawns, from(From), to(To))) :-
    true(control(Player)) &
    true(cell(From, situation(army(of(Player), count(StationaryPawns)), _))) &
    player(Player) &
    neighboring_coordinates(From, To) &
    stack(MovingPawns) &
    le(MovingPawns, StationaryPawns).
legal(Player, spawn(at(StartPosition))) :-
    true(control(Player)) &
    start_position(Player, StartPosition) &
    true_for_each_cell_occupation(free).

goal(random, 0).
goal(Player, Score) :-
    player_score(Player, Score).

% Games ends if all board is captured
terminal :-
    player(Player) &
    true_for_each_cell(captured_by(Player)).

% TODO: Game ends if an opposite side of a board is captured
%terminal :-
%    player(red) &
%    cell(rc(3,3), captured_by(red), _).

next(cell(FromAndTo, captured_by(Player), with_pawn(of(Player), number(MovingPawns)))) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, capture).

next(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, nothing).

next(cell(FromAndTo, OldCapture, free)) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, minusone).

% Destination is captured by player according to rule book and all pawns appear there
next(cell(To, captured_by(Player), with_pawn(of(Player), number(MovingPawns)))) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D, Capture, capture).

next(cell(To, Capture, with_pawn(of(Player), number(MovingPawns)))) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D, Capture, nothing).

next(cell(To, Capture, free)) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(_, from(From), to(To))) &
    true(cell(To, Capture, _)) &
    distinct(From, To) &
    rule_outcome(Player, D, Capture, minusone).

% Origin retains its capture state and ALL pawns are removed
next(cell(From, OldCapture, free)) :-
    player(Player) &
    does(random, _) &
    does(Player, move(_, from(From), to(To))) &
    distinct(From, To) &
    true(cell(From, OldCapture, _)).

% All other cells should retains their respective state
next(cell(Rc, OldCapture, OldPawnState)) :-
    player(Player) &
    does(random, _) &
    does(Player, move(_, from(From), to(To))) &
    true(cell(Rc, OldCapture, OldPawnState)) &
    distinct(Rc, From) &
    distinct(Rc, To).

% All other cells should retains their respective state
next(cell(Rc, OldCapture, OldPawnState)) :-
    does(_, spawn(at(Spawn))) &
    true(cell(Rc, OldCapture, OldPawnState)) &
    distinct(Rc, Spawn).

next(cell(Spawn, OldCapture, with_pawn(of(Player), number(1)))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, OldCapture, _)).

% There is no transfer of control
next(control(Player)) :-
    player(Player) &
    true(control(Player)).

next(last_roll(D6, Outcome)) :-
    rich_ui(last_roll) &
    player(Player) &
    does(random, roll([D6])) &
    does(Player, move(_, from(_), to(To))) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D6, Capture, Outcome).

% Input utils
player_score(Player, 100) :-
    true_for_each_cell(captured_by(Player)).
player_score(Player, 50) :-
    true(cell(_, wild, _)) &
    true(cell(_, captured_by(Player), _)).
player_score(Player, 0) :-
    player(Player) &% Fixes unsafe rule warning
    true_for_each_cell(wild).

%% TODO: Implement it in GDL
%alt_player_score(Player, NumberOfCapturedCells) :-
%    player(Player) &
%    findall(I, (I=cell(_, captured_by(Player), _), true(I)), L) &
%    length(L, NumberOfCapturedCells).

true_for_each_cell(Capture) :-
    true(cell(rc(1,1), Capture, _)) &
    true(cell(rc(1,2), Capture, _)) &
    true(cell(rc(1,3), Capture, _)) &
    true(cell(rc(2,1), Capture, _)) &
    true(cell(rc(2,2), Capture, _)) &
    true(cell(rc(2,3), Capture, _)) &
    true(cell(rc(3,1), Capture, _)) &
    true(cell(rc(3,2), Capture, _)) &
    true(cell(rc(3,3), Capture, _)).

true_for_each_cell_occupation(Occupation) :-
    true(cell(rc(1,1), _, Occupation)) &
    true(cell(rc(1,2), _, Occupation)) &
    true(cell(rc(1,3), _, Occupation)) &
    true(cell(rc(2,1), _, Occupation)) &
    true(cell(rc(2,2), _, Occupation)) &
    true(cell(rc(2,3), _, Occupation)) &
    true(cell(rc(3,1), _, Occupation)) &
    true(cell(rc(3,2), _, Occupation)) &
    true(cell(rc(3,3), _, Occupation)).

% Utils with complete definitions
row(I) :-
    max_row(MaxRow) &
    le(1, I) & le(I, MaxRow).

col(I) :-
    max_col(MaxCol) &
    le(1, I) & le(I, MaxCol).

% TODO: Consider removing stack/1
stack(PossiblePawnStack) :-
    max_stack(MaxStack) &
    le(1, PossiblePawnStack) & le(PossiblePawnStack, MaxStack).

neighboring_coordinates(A, B) :-
    valid_rc(A) &
    valid_rc(B) &
    neighboring_coordinates_aux(A, B).
neighboring_coordinates_aux(rc(R,C), rc(R,C)) :- val(R) & val(C).
neighboring_coordinates_aux(rc(R,Lc), rc(R,Rc)) :- val(R) & s(Lc, Rc).
neighboring_coordinates_aux(rc(R,Lc), rc(R,Rc)) :- val(R) & s(Rc, Lc).
neighboring_coordinates_aux(rc(Lr,C), rc(Rr,C)) :- val(C) & s(Lr, Rr).
neighboring_coordinates_aux(rc(Lr,C), rc(Rr,C)) :- val(C) & s(Rr, Lr).

nrules(S, dice([]), S) :-
    valid_situation_0(S).
nrules(Before, Roll, situation(army(ReturnArmy, count(A)), ReturnOn)) :-
    head_tail_of_dice(D6, T, Roll) &
    counted_dice(Roll, succ(N)) &
    count_of_situation(Before, succ(N)) &
    rules_(Before, die(D6), situation(army(Of, count(C)), On)) &
    unify_dice(dice(T), DiceTail) &
    nrules(Next, DiceTail, Return) &
    add(A, succ(N), Tmp) & add(succ(R), C, Tmp) &
    valid_situation(situation(army(ReturnArmy, count(A)), ReturnOn)) &
    unify_situation(situation(army(Of, count(N)), On), Next) &
    unify_situation(situation(army(ReturnArmy, count(R)), ReturnOn), Return).

nrules_outcome(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(nobody, On)) :-
    nrules(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(_, count(0)), On)).
nrules_outcome(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(OfAfter, count(succ(A))), OnAfter)) :-
    nrules(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(OfAfter, count(succ(A))), OnAfter)).


rules(S, L) :-
    unify_situation(S, situation(army(of(P), _, on(_, owned_by(P))))) &
    rules(own, any, L).
rules(S, L) :-
    unify_situation(S, situation(army(of(_), _, on(Tile, wild       )))) &
    rules(wild, Tile, L).
rules(S, L) :-
    unify_situation(S, situation(army(of(P), _, on(Tile, owned_by(Q))))) &
    distinct(P, Q) &
    rules(foreign, Tile, L).

rules_(Before, die(D), After) :-
    rule_book(Before, L) &
    nth_element(outcome, D, L, Outcome) &
    rule_b_outcome(Outcome, Before, After).

rule_b_outcome(minus(N), Before, After) :-
    unify_situation(Before, situation(army(Of, count(B)), On)) &
    add(ns(N, _), ns(_, A), ns(_, B)) &
    unify_situation(After, situation(army(Of, count(A)), On)).
rule_b_outcome(plus(N), Before, After) :-
    unify_situation(Before, situation(army(Of, count(B)), On)) &
    add(ns(N, _), ns(_, B), ns(_, A)) &
    unify_situation(After, situation(army(Of, count(A)), On)).
rule_b_outcome(nothing, Before, After) :-
    unify_situation(Before, After).
rule_b_outcome(capture, Before, After) :-
    unify_situation(Before, situation(army(of(P), Count, on(Tile, _)))) &
    unify_situation(After, situation(army(of(P), Count, on(Tile, owned_by(P))))).

count_of_situation(situation(army(Of, count(X)), On), X) :-
    valid_situation(situation(army(Of, count(X)), On)).

% Unification predicates
unify_situation(A, A) :- valid_situation(A).
unify_die(A, A) :- valid_die(A).

% Validation predicates
valid_outcome(capture).
valid_outcome(nothing).
valid_outcome(minus(N)) :- val(N).
valid_outcome(plus(N)) :- val(N).

valid_tile(field).
valid_tile(town).
valid_tile(garrison).
valid_tile(fort).

valid_situation_0(situation(army(of(Player), count(0)), On)) :-
    valid_situation(situation(nobody, On)) &
    player(Player).

valid_situation(situation(Occupation, on(Tile,  Ownership))) :-
    valid_occupation(Occupation) &
    valid_tile(Tile) &
    valid_ownerhip(Ownership).

valid_ownerhip(wild).
valid_ownerhip(owned_by(Player)) :-
    player(Player).

valid_occupation(nobody).
valid_occupation(army(of(Player), count(X))) :-
    player(Player) &
    is_succ(X).

valid_occupation_non_0(nobody).
valid_occupation_non_0(army(of(Player), count(succ(X)))) :-
    player(Player) &
    is_succ(X).

valid_cell(cell(Coordinates, Situation)) :-
    valid_rc(Coordinates) &
    valid_occupation_non_0(Occupation) &
    unify_situation(Situation, situation(Occupation, _)).

valid_rc(rc(Row, Column)) :-
    row(Row) &
    col(Column).

valid_die(1).
valid_die(2).
valid_die(3).
valid_die(4).
valid_die(5).
valid_die(6).

% Dice utils
d6(1). d6(2). d6(3). d6(4). d6(5). d6(6).
roll_d6(N, L) :- type_nl(d6, nl(N, L)).
head_tail_of_dice(H, T, dice(L)) :- type_list_head_tail(d6, L, H, T).
counted_dice(dice(L), N) :- type_nl(d6, nl(N, L)).

% List utils
type(d6).
type(outcome).
type_element(d6, Element) :- d6(Element).
type_element(outcome, Element) :- outcome(Element).

type_nl_00(Tp, []) :- type(Tp).
type_nl_01(Tp, [H]) :- type_element(Tp, H) & type_nl_00(Tp, []).
type_nl_02(Tp, [H,T1]) :- type_element(Tp, H) & type_nl_01(Tp, [T1]).
type_nl_03(Tp, [H,T1,T2]) :- type_element(Tp, H) & type_nl_02(Tp, [T1,T2]).
type_nl_04(Tp, [H,T1,T2,T3]) :- type_element(Tp, H) & type_nl_03(Tp, [T1,T2,T3]).
type_nl_05(Tp, [H,T1,T2,T3,T4]) :- type_element(Tp, H) & type_nl_04(Tp, [T1,T2,T3,T4]).
type_nl_06(Tp, [H,T1,T2,T3,T4,T5]) :- type_element(Tp, H) & type_nl_05(Tp, [T1,T2,T3,T4,T5]).
type_nl(Tp, nl(0, [])) :- type_nl_00(Tp, []).
type_nl(Tp, nl(1, [H])) :- type_nl_01(Tp, [H]).
type_nl(Tp, nl(2, [H,T1])) :- type_nl_02(Tp, [H,T1]).
type_nl(Tp, nl(3, [H,T1,T2])) :- type_nl_03(Tp, [H,T1,T2]).
type_nl(Tp, nl(4, [H,T1,T2,T3])) :- type_nl_04(Tp, [H,T1,T2,T3]).
type_nl(Tp, nl(5, [H,T1,T2,T3,T4])) :- type_nl_05(Tp, [H,T1,T2,T3,T4]).
type_nl(Tp, nl(6, [H,T1,T2,T3,T4,T5])) :- type_nl_06(Tp, [H,T1,T2,T3,T4,T5]).
%type_list_head_tail(Tp, H!T,  H, T) :- type_nl(Tp, nl(_,  H!T )).
type_list_head_tail(Tp, [H|T], H, T) :- type_nl(Tp, nl(_, [H|T])).

nth_element(Tp, 1, L, H) :-
    type_list_head_tail(Tp, L, H, _).
nth_element(Tp, N, L, E) :-
    type_list_head_tail(Tp, L, _, T) &
    add(1, M, N) &
    nth_element(Tp, M, T, E).

% Arithmetic utils
val(A) :- ns_val(ns(A, _)).
eq(A, A) :- ns_eq(ns(A, S), ns(A, S)).
le(A, B) :- ns_le(ns(A, _), ns(B, _)).
lt(A, B) :- ns_lt(ns(A, _), ns(B, _)).
add(A, B, C) :- ns_sum(ns(A, _), ns(B, _), ns(C, _)).
mul(A, B, C) :- ns_mul(ns(A, _), ns(B, _), ns(C, _)).
pow(A, B, C) :- ns_pow(ns(A, _), ns(B, _), ns(C, _)).

ns_pow(ns(An, succ(S)), ns(0, 0), ns(1, succ(0))) :-
    ns_val(ns(An, succ(S))).
ns_pow(A, B, C) :-
    ns_suc(Bm1, B) &
    ns_pow(A, Bm1, Part) &
    ns_mul(Part, A, C).
ns_mul(ns(0, 0), B, ns(0, 0)) :-
    ns_val(B).
ns_mul(A, B, C) :-
    ns_suc(Am1, A) &
    ns_mul(Am1, B, Part) &
    ns_sum(B, Part, C).
ns_sum(ns(0, 0), B, B) :-
    ns_val(B).
ns_sum(A, B, C) :-
    ns_suc(Am1, A) &
    ns_sum(Am1, B, X) &
    ns_suc(X, C) &
    ns_val(B).
ns_suc(ns(An, As), ns(Bn, succ(As))) :-
    ns_val(ns(An, As)) &
    ns_val(ns(Bn, succ(As))).
ns_le(A, A) :-
    ns_val(A).
ns_le(A, B) :-
    ns_suc(X, B) &
    ns_le(A, X) &
    ns_val(A).
ns_eq(A, A) :-
    ns_le(A, A).
ns_lt(A, B) :-
    ns_le(A, B) &
    distinct(A, B).

ns_val(ns( 0, 0)).
ns_val(ns( 1, succ(0))).
ns_val(ns( 2, succ(succ(0)))).
ns_val(ns( 3, succ(succ(succ(0))))).
ns_val(ns( 4, succ(succ(succ(succ(0)))))).
ns_val(ns( 5, succ(succ(succ(succ(succ(0))))))).
ns_val(ns( 6, succ(succ(succ(succ(succ(succ(0)))))))).
ns_val(ns( 7, succ(succ(succ(succ(succ(succ(succ(0))))))))).
ns_val(ns( 8, succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))).
ns_val(ns( 9, succ(succ(succ(succ(succ(succ(succ(succ(succ(0))))))))))).
ns_val(ns(10, succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))))).

% Prolog code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Arithmetic tests
all_arithmetics_tests_are_passing :-
    all_arithmetic_predicates_always_halt,
    all_numbers_are_legal,
    all_le_tests,
    all_summation_tests.

all_numbers_are_legal :-
    \+val_generates_illegal_number(_).
val_generates_illegal_number(N) :-
    val(N), \+number(N).

all_le_tests :-
    \+le_test_1(_,_),
    \+given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(_,_,_),
    \+there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(_,_).
le_test_1(A, B) :-
    le(A, B), le(B, A), A \= B.
given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(A, B, X) :-
    le(A, B), A \= B, le(X, A), le(B, X).
there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(A, X) :-
    le(X, A), le(A, X), A \= X.

all_summation_tests :-
    example_1_plus_2_equals_3,
    example_1_plus_2_is_never_equal_to_any_number_other_than_3,
    sum_of_2_non_0_numbers_is_never_less_then_any_of_summands.
example_1_plus_2_equals_3 :-
    add(1, 2, 3).
example_1_plus_2_is_never_equal_to_any_number_other_than_3 :-
    \+example_1_plus_2_is_equal_to_a_number_other_than_3(_).
example_1_plus_2_is_equal_to_a_number_other_than_3(C) :-
    add(1, 2, C), C \= 3.
sum_of_2_non_0_numbers_is_never_less_then_any_of_summands :-
    \+sum_of_2_non_0_numbers_is_less_then_any_of_summands(_,_,_).
sum_of_2_non_0_numbers_is_less_then_any_of_summands(A,B,C) :-
    add(A, B, C),
    A \= 0,
    B \= 0,
    (
        le(C, A);
        le(C, A)
    ).

all_arithmetic_predicates_always_halt :-
    always_halts(val(_)),
    always_halts(eq(_, _)),
    always_halts(le(_, _)),
    always_halts(lt(_, _)),
    always_halts(add(_, _, _)),
    always_halts(mul(_, _, _)),
    always_halts(pow(_, _, _)).

% Rules tests
% TODO: Perform tests for all possible board configurations
% TODO: All players have at least 1 legal move in current non-terminal state
all_statements_about_current_configuration_are_valid :-
    \+invalid_statement_for_current_configuration_exists(_).
invalid_statement_for_current_configuration_exists(I) :-
    true(I),
    \+base(I).

all_legal_moves_for_current_configuration_are_valid :-
    \+invalid_but_legal_move_for_current_configuration_exists(_, _).
invalid_but_legal_move_for_current_configuration_exists(Role, Move) :-
    legal(Role, Move),
    \+input(Role, Move).

all_roles_have_a_score_for_current_configuration :-
    \+there_is_a_role_without_a_score_for_current_configuration(_).
there_is_a_role_without_a_score_for_current_configuration(Role) :-
    role(Role),
    \+goal(Role, _).

all_scores_are_unambiguous_for_current_configuration :-
    \+there_is_a_role_with_ambiguous_score(_).
there_is_a_role_with_ambiguous_score(Role) :-
    role(Role),
    \+role_scores_are_unambiguous(Role).
role_scores_are_unambiguous(Role) :-
    findall(Score, (goal(Role, Score)), AllScores),
    list_of_identical_values(AllScores).

user_cannot_move_0_pawns :-
    \+pawn_0.
pawn_0 :-
    stack(NumberOfAllowedPawns),
    \+le(0, NumberOfAllowedPawns).

current_state_is_not_terminal :-
    \+terminal.

all_rules_tests_are_passing :-
    rules_should_terminate_if_count_is_set_but_dice_list_is_not(_, _),
    rules_should_terminate_if_dice_list_is_set_but_count_is_not(_, _),
    all_rules(red-on(field, wild), [6,6,1,1], [situation(army(of(red), count( succ(succ(succ(succ(0)))) )), on(field,wild))]),
    all_rules(red-on(field, wild), [2,1,1,4], [situation(army(of(red), count( succ(succ(0))  )), on(field,owned_by(red)))]),
    all_rules(red-on(field, wild), [1,2,5,6], [situation(army(of(red), count( succ(succ(succ(0))) )), on(field,owned_by(red)))]),
    all_rules(red-on(field, owned_by(red)), [1], [situation(army(of(red), count( succ(0) )), on(field,owned_by(red)))]).

rules_should_terminate_if_count_is_set_but_dice_list_is_not(L0, L1) :-
    findall(D, (nrules(situation(army(of(red), count(0)), on(field, wild)), D, _)), L0),
    findall(D, (nrules(situation(army(of(red), count(1)), on(field, wild)), D, _)), L1).
rules_should_terminate_if_dice_list_is_set_but_count_is_not(L0, L1) :-
    findall(Before, (nrules(Before, dice([]), _)), L0),
    findall(Before, (nrules(Before, dice([1]), _)), L1).
all_rules(Player-On, Dice, AllPossibleOutcomes) :-
    findall(After, nrules(situation(army(of(Player), count(_)), On), dice(Dice), After), AllPossibleOutcomes).

all_tests_are_passing :-
   *all_statements_about_current_configuration_are_valid,
   *all_legal_moves_for_current_configuration_are_valid,
   *all_roles_have_a_score_for_current_configuration,
   *all_scores_are_unambiguous_for_current_configuration,
   *current_state_is_not_terminal,
   *all_rules_tests_are_passing,
    all_arithmetics_tests_are_passing,
   *user_cannot_move_0_pawns.

list_of_identical_values([]).
list_of_identical_values([H|T]) :-
    value_of_all_elements_of_a_list(H, T).
value_of_all_elements_of_a_list(_, []).
value_of_all_elements_of_a_list(H, [H|T]) :-
    value_of_all_elements_of_a_list(H, T).

always_halts(Goal) :-
    \+doesnt_halt(Goal).
doesnt_halt(Goal) :-
    call(Goal), false.

% Assert that current configuration is initial
true(X) :- init(X).

'&'(Lhs, Rhs) :-
    call(Lhs), call(Rhs).
'|'(Lhs, Rhs) :-
    call(Lhs) ; call(Rhs).
'~'(Rhs) :-
    \+ call(Rhs).
'*'(_).

'$_error_stream'(user_error).
'$'(Goal) :-
    '$_error_stream'(ErrorStream),
    portray_clause(ErrorStream, call:Goal),
    $-Goal,
    portray_clause(ErrorStream, exit:Goal).
'$-'(Goal) :-
    '$_error_stream'(ErrorStream),
    catch(
        Goal,
        Exception,
        (
            portray_clause(ErrorStream, excp:Exception:Goal),
            throw(Exception)
        )
    ).

% FIXME: It looks like distinct/2 should behave like dif/2
distinct(A, B) :- A \= B.
