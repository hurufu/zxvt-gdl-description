% Not quite Capture of the Territory
% 1 player
% Board 3Ã—3
% No buildings
% Pawns can't be stacked and only single pawn can be placed on the board
% Goal is to capture the whole board
% Each player is movin simultaneously with a random role
% TODO: Consider adding different game tactic, where each roles moves separately

% WARNING: Remove to get valid program in GDL-II (HRF)
:- op(1000, xfy, '&').
:- op(1100, xfy, '|').
:- op(900, fy, '~').
:- op(950, fy, '*').
:- op(900, fy, '$').
:- op(900, fy, '$-').
:- op(900, fy, '?').
:- op(1050, xfy, '~>').
:- initialization(all_tests_are_passing).

% Configuration %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

max_row(3).
max_col(3).
player(red).
start_position(red, rc(1,1)).
rich_ui(no_rich_ui).%Avoid exception if all UI enrichments are disabled
rich_ui(last_roll).
rules(own,     field,    [nothing ,nothing ,nothing ,nothing ,nothing,nothing]).
rules(wild,    field,    [minus(1),nothing ,nothing ,capture ,capture,plus(1)]).
%rules(wild,    town,     [minus(1),minus(1),nothing ,capture ,plus(1),plus(1)]).
%rules(wild,    garrison, [minus(1),minus(1),minus(1),nothing ,capture,plus(1)]).
%rules(wild,    fort,     [minus(1),minus(1),minus(1),capture ,plus(1),plus(1)]).
rules(foreign, field,    [minus(1),minus(1),nothing ,nothing ,capture,capture]).
rules(foreign, town,     [minus(1),minus(1),nothing ,nothing ,nothing,capture]).
rules(foreign, garrison, [minus(1),minus(1),minus(1),nothing ,capture,capture]).
rules(foreign, fort,     [minus(1),minus(1),minus(1),minus(1),nothing,capture]).

% GDL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

role(random).
role(red).

% Random player can only roll a list of dice (D6)
% TODO: Consider making number of die sides configurable
input(random, roll(L)) :-
    valid_dice(L).
% Any player can move at least 1 pawn to any neighboring cell
input(Player, Move) :-
    player(Player) &
    valid_move(Move).
% Any player can spawn pawns only at a starting position
input(Player, spawn(at(StartPosition))) :-
    start_position(Player, StartPosition).

base(Cell) :- valid_cell(Cell).
base(control(R)) :- player(R).
base(last_roll(D, Outcome)) :-
    rich_ui(last_roll) &
    valid_die(D) &
    valid_outcome(Outcome).

init(cell(StartPosition, situation(army(of(Player), count(1)), on(field, owned_by(Player))))) :-
    start_position(Player, StartPosition).
init(Cell) :-
    unify_cell(Cell, cell(Rc, situation(nobody, on(field, wild)))) &
    start_position(_, StartPosition) &
    distinct(StartPosition, Rc).
init(control(red)).

% Random player may throw only as many dice as the largest pawn stack of the current player
% TODO: If all possible moves end-up on the already captured cell, ie no dice roll is needed, then random shouldn't roll dice
legal(random, roll(Dice)) :-
    true(control(Player)) &
    max_possible_pawn_stack(Player, Max) &
    valid_dice(Max, Dice).
% Player can move to a neighboring own or not occupied cell with all or less pawns
legal(Player, move(MovingPawns, from(From), to(To))) :-
    true(control(Player)) &
    true(cell(From, situation(army(of(Player), count(StationaryPawns)), _))) &
    le(MovingPawns, StationaryPawns) &
    valid_move(move(MovingPawns, from(From), to(To))) &
    (
        true(cell(To, situation(army(of(Player), _), _))) |
        true(cell(To, situation(nobody, _)))
    ),
    distinct(From, To).
% It's not legal to move only part of a stack to the same cell as currently standing on
legal(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) :-
    true(control(Player)) &
    true(cell(FromAndTo, situation(army(of(Player), count(MovingPawns)), _))) &
    valid_move(move(MovingPawns, from(FromAndTo), to(FromAndTo))).
% A new pawn can be spawned only if current player doesn't have any pawn left
% and it should be the only choice for a player in such situation
legal(Player, spawn(at(StartPosition))) :-
    true(control(Player)) &
    start_position(Player, StartPosition) &
    (
        true_for_each_cell(situation(nobody, _)) |
        (
            true_for_each_cell(situation(army(of(Oponent), _), _)) &
            distinct(Player, Oponent)
        )
    ).

% TODO: goal/2 should succeed only once for any player
goal(random, 0).
goal(Player, Score) :-
    player_score(Player, Score).

% Games ends if all board is captured, ie there are no wild cells left
terminal :-
    true_for_each_cell(situation(_, on(_, owned_by(_)))).

% TODO: Game ends if an opposite side of a board is captured
%terminal :-
%    player(red) &
%    cell(rc(3,3), captured_by(red), _).

% If a player choses to recapture the cell that he is already standing on, then just proceed by the rules
next(cell(FromAndTo, NewSituation)) :-
    does(random, roll(D)) &
    does(_, move(_, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldSituation)) &
    nrules(OldSituation, D, NewSituation).

% If a cell already contains a players pawn, then a sum must be calculated
next(cell(To, NewSituation)) :-
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, situation(army(of(Player), count(StationaryPawns)), On))) &
    add(StationaryPawns, MovingPawns, NewPawns) &
    nrules(situation(army(of(Player), count(NewPawns)), On), NewSituation).

% Destination is captured by player according to rule book and all pawns appear there, if a cell doesn't have any pawn
next(cell(To, NewSituation)) :-
    does(random, roll(D)) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, situation(nobody, On))) &
    nrules(situation(army(of(Player), count(MovingPawns)), On), D, NewSituation).

% Origin retains its capture state and moved pawns are removed
next(cell(From, NewSituation)) :-
    does(_, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(From, situation(army(Of, count(OldPawns)), On))) &
    add(NewPawns, MovingPawns, OldPawns) &
    unify_situation(NewSituation, situation(army(Of, count(NewPawns)), On)).

% All other cells should retains their respective state
next(cell(Rc, Situation)) :-
    does(_, move(_, from(From), to(To))) &
    true(cell(Rc, Situation)) &
    distinct(Rc, From) &
    distinct(Rc, To).

% All other cells should retains their respective state
next(cell(Rc, Situation)) :-
    does(_, spawn(at(Spawn))) &
    true(cell(Rc, Situation)) &
    distinct(Rc, Spawn).

next(cell(Spawn, situation(army(of(Player), count(NewCount)), On))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, situation(army(of(Player), count(OldCount)), On))) &
    add(1, OldCount, NewCount).

next(cell(Spawn, situation(army(of(Player), count(1)), On))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, situation(nobody, On))).

% TODO: Implement transfer of control
next(control(Player)) :-
    true(control(Player)).

% TODO: Add outcome to the last_roll state
next(last_roll(Dice)) :-
    rich_ui(last_roll) &
    does(random, roll(Dice)).

% Input utils
player_score(Player, 100) :-
    true_for_each_cell(situation(_, on(_, owned_by(Player)))).
player_score(Player, 50) :-
    true(cell(_, situation(_, on(_, wild)))) &
    true(cell(_, situation(_, on(_, owned_by(Player))))).
player_score(Player, 0) :-
    player(Player) &% Fixes unsafe rule warning
    true_for_each_cell(situation(_, on(_, wild))).

%% TODO: Implement it in GDL
%alt_player_score(Player, NumberOfCapturedCells) :-
%    player(Player) &
%    findall(I, (I=cell(_, captured_by(Player), _), true(I)), L) &
%    length(L, NumberOfCapturedCells).

true_for_each_cell(Situation) :-
    valid_situation(Situation) &
    ~there_is_a_cell_with_a_distinct_situation(Situation).
there_is_a_cell_with_a_distinct_situation(Situation) :-
    true(cell(Rc, S)) &
    valid_situation(S) &
    distinct(S, Situation) &
    valid_rc(Rc).

% TODO: max_possible_pawn_stack/2 should succeed only once
max_possible_pawn_stack(Player, MaxPossiblePawnStack) :-
    possible_pawn_stack(Player, MaxPossiblePawnStack) &
    ~there_are_possible_stacks_larger_than_the_given_one(Player, MaxPossiblePawnStack).
max_possible_pawn_stack(Player, 0) :-
    player(Player) &
    ~there_is_a_cell_occupied_by_player(Player).
there_are_possible_stacks_larger_than_the_given_one(Player, MaxPossiblePawnStack) :-
    player(Player) &
    lt(MaxPossiblePawnStack, N) &
    possible_pawn_stack(Player, N).
possible_pawn_stack(Player, PossiblePawnStack) :-
    true(cell(From, situation(army(of(Player), count(M)), _))) &
    valid_move(move(M, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, situation(army(of(Player), count(N)), _))) &
    add(M, N, PossiblePawnStack).
possible_pawn_stack(Player, PossiblePawnStack) :-
    true(cell(_, situation(army(of(Player), count(PossiblePawnStack)), _))).

there_is_a_cell_occupied_by_player(Player) :-
    true(cell(_, situation(army(of(Player), _), _))).

% Utils with complete definitions
neighboring_rc(A, B) :-
    valid_rc(A) &
    valid_rc(B) &
    neighboring_rc_aux(A, B).
neighboring_rc_aux(rc(R,C), rc(R,C)) :- num(R) & num(C).
neighboring_rc_aux(rc(R,Lc), rc(R,Rc)) :- num(R) & add(1, Lc, Rc).
neighboring_rc_aux(rc(R,Lc), rc(R,Rc)) :- num(R) & add(1, Rc, Lc).
neighboring_rc_aux(rc(Lr,C), rc(Rr,C)) :- num(C) & add(1, Lr, Rr).
neighboring_rc_aux(rc(Lr,C), rc(Rr,C)) :- num(C) & add(1, Rr, Lr).

nrules(S, dice([]), S) :-
    valid_situation_0(S).
nrules(Before, Roll, situation(army(ReturnArmy, count(A)), ReturnOn)) :-
    head_tail_of_dice(D6, T, Roll) &
    counted_dice(Roll, succ(N)) &
    count_of_situation(Before, succ(N)) &
    rules_(Before, die(D6), situation(army(Of, count(C)), On)) &
    unify_dice(dice(T), DiceTail) &
    nrules(Next, DiceTail, Return) &
    add(A, succ(N), Tmp) & add(succ(R), C, Tmp) &
    valid_situation(situation(army(ReturnArmy, count(A)), ReturnOn)) &
    unify_situation(situation(army(Of, count(N)), On), Next) &
    unify_situation(situation(army(ReturnArmy, count(R)), ReturnOn), Return).

nrules_outcome(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(nobody, On)) :-
    nrules(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(_, count(0)), On)).
nrules_outcome(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(OfAfter, count(succ(A))), OnAfter)) :-
    nrules(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(OfAfter, count(succ(A))), OnAfter)).

situation_rules(S, L) :-
    unify_situation(S, situation(army(of(P), count(X)), on(Tile, owned_by(P)))) &
    distinct(X, 0) &
    rules(own, Tile, L).
situation_rules(S, L) :-
    unify_situation(S, situation(army(of(_), count(X)), on(Tile, wild))) &
    distinct(X, 0) &
    rules(wild, Tile, L).
situation_rules(S, L) :-
    unify_situation(S, situation(army(of(P), count(X)), on(Tile, owned_by(Q)))) &
    distinct(X, 0) &
    distinct(P, Q) &
    rules(foreign, Tile, L).

situation_after_single_throw(Before, die(D), After) :-
    situation_rules(Before, L) &
    nth_element(valid_outcome, D, L, Outcome) &
    rule_b_outcome(Outcome, Before, After).

rule_b_outcome(minus(N), Before, After) :-
    unify_situation(Before, situation(army(Of, count(B)), On)) &
    add(ns(N, _), ns(_, A), ns(_, B)) &
    unify_situation(After, situation(army(Of, count(A)), On)).
rule_b_outcome(plus(N), Before, After) :-
    unify_situation(Before, situation(army(Of, count(B)), On)) &
    add(ns(N, _), ns(_, B), ns(_, A)) &
    unify_situation(After, situation(army(Of, count(A)), On)).
rule_b_outcome(nothing, Before, After) :-
    unify_situation(Before, After).
rule_b_outcome(capture, Before, After) :-
    unify_situation(Before, situation(army(of(P), Count, on(Tile, _)))) &
    unify_situation(After, situation(army(of(P), Count, on(Tile, owned_by(P))))).

count_of_situation(situation(army(Of, count(X)), On), X) :-
    valid_situation(situation(army(Of, count(X)), On)).

% Unification predicates
unify_situation(A, A) :- valid_situation(A).
unify_die(A, A) :- valid_die(A).
unify_cell(A, A) :- valid_cell(A).

% Validation predicates
valid_outcome(capture).
valid_outcome(nothing).
valid_outcome(minus(N)) :- le(1, N).
valid_outcome(plus(N)) :- le(1, N).

valid_tile(field).
valid_tile(town).
valid_tile(garrison).
valid_tile(fort).

valid_situation_0(situation(army(of(Player), count(0)), On)) :-
    valid_situation(situation(nobody, On)) &
    player(Player).

valid_situation(situation(Occupation, on(Tile,  Ownership))) :-
    valid_occupation(Occupation) &
    valid_tile(Tile) &
    valid_ownerhip(Ownership).

valid_ownerhip(wild).
valid_ownerhip(owned_by(Player)) :-
    player(Player).

valid_occupation(nobody).
valid_occupation(army(of(Player), count(X))) :-
    player(Player) &
    num(X).

valid_occupation_non_0(nobody).
valid_occupation_non_0(army(of(Player), count(succ(X)))) :-
    player(Player) &
    num(X).

valid_cell(cell(Coordinates, Situation)) :-
    valid_rc(Coordinates) &
    valid_situation(Situation).

valid_row(I) :-
    max_row(MaxRow) &
    le(1, I) & le(I, MaxRow).

valid_col(I) :-
    max_col(MaxCol) &
    le(1, I) & le(I, MaxCol).

valid_rc(rc(Row, Column)) :-
    valid_row(Row) &
    valid_col(Column).

valid_die(1).
valid_die(2).
valid_die(3).
valid_die(4).
valid_die(5).
valid_die(6).
valid_dice(L) :-
    type_nl(valid_die, nl(_, L)).
valid_dice(Number, Dice) :-
    type_nl(valid_die, nl(Number, Dice)).

valid_move(move(NumberOfPawns, from(From), to(To))) :-
    le(1, NumberOfPawns) &
    neighboring_rc(From, To).

% Dice utils
head_tail_of_dice(H, T, dice(L)) :- type_list_head_tail(valid_die, L, H, T).
counted_dice(dice(L), N) :- type_nl(valid_die, nl(N, L)).

% List utils
type(valid_outcome).
type(valid_die).
%type(num).
type_element(valid_outcome, Element) :- valid_outcome(Element).
type_element(valid_die, Element) :- valid_die(Element).
%type_element(num, Element) :- num(Element).

% TODO: Optimize list implementation
type_nl_00(Tp, []) :- type(Tp).
type_nl_01(Tp, [H]) :- type_element(Tp, H) & type_nl_00(Tp, []).
type_nl_02(Tp, [H,T1]) :- type_element(Tp, H) & type_nl_01(Tp, [T1]).
type_nl_03(Tp, [H,T1,T2]) :- type_element(Tp, H) & type_nl_02(Tp, [T1,T2]).
type_nl_04(Tp, [H,T1,T2,T3]) :- type_element(Tp, H) & type_nl_03(Tp, [T1,T2,T3]).
type_nl_05(Tp, [H,T1,T2,T3,T4]) :- type_element(Tp, H) & type_nl_04(Tp, [T1,T2,T3,T4]).
type_nl_06(Tp, [H,T1,T2,T3,T4,T5]) :- type_element(Tp, H) & type_nl_05(Tp, [T1,T2,T3,T4,T5]).
type_nl(Tp, nl(0, [])) :- type_nl_00(Tp, []).
type_nl(Tp, nl(1, [H])) :- type_nl_01(Tp, [H]).
type_nl(Tp, nl(2, [H,T1])) :- type_nl_02(Tp, [H,T1]).
type_nl(Tp, nl(3, [H,T1,T2])) :- type_nl_03(Tp, [H,T1,T2]).
type_nl(Tp, nl(4, [H,T1,T2,T3])) :- type_nl_04(Tp, [H,T1,T2,T3]).
type_nl(Tp, nl(5, [H,T1,T2,T3,T4])) :- type_nl_05(Tp, [H,T1,T2,T3,T4]).
type_nl(Tp, nl(6, [H,T1,T2,T3,T4,T5])) :- type_nl_06(Tp, [H,T1,T2,T3,T4,T5]).
%type_list_head_tail(Tp, H!T,  H, T) :- type_nl(Tp, nl(_,  H!T )).
type_list_head_tail(Tp, [H|T], H, T) :- type_nl(Tp, nl(_, [H|T])).

nth_element(Tp, 1, L, H) :-
    type_list_head_tail(Tp, L, H, _).
nth_element(Tp, N, L, E) :-
    type_list_head_tail(Tp, L, _, T) &
    add(1, M, N) &
    nth_element(Tp, M, T, E).

%% Numeric list utils
%num_list_head_tail(List, H, T) :-
%    type_list_head_tail(num, List, H, T).
%max_element([Max], Max).
%max_element(L, Max) :-
%    num_list_head_tail(L, H, T) &
%    max_element(T, OldMax) &
%    maximum(H, OldMax, Max).

% Arithmetic utils
num(A) :- ns_val(ns(A, _)).
eq(A, A) :- ns_eq(ns(A, S), ns(A, S)).
le(A, B) :- ns_le(ns(A, _), ns(B, _)).
lt(A, B) :- ns_lt(ns(A, _), ns(B, _)).
add(A, B, C) :- ns_add(ns(A, _), ns(B, _), ns(C, _)).
%mul(A, B, C) :- ns_mul(ns(A, _), ns(B, _), ns(C, _)).
%pow(A, B, C) :- ns_pow(ns(A, _), ns(B, _), ns(C, _)).
maximum(A, B, A) :- lt(B, A).
maximum(A, B, B) :- le(A, B).

%ns_pow(ns(An, succ(S)), ns(0, 0), ns(1, succ(0))) :-
%    ns_val(ns(An, succ(S))).
%ns_pow(A, B, C) :-
%    ns_suc(Bm1, B) &
%    ns_pow(A, Bm1, Part) &
%    ns_mul(Part, A, C).
%ns_mul(ns(0, 0), B, ns(0, 0)) :-
%    ns_val(B).
%ns_mul(A, B, C) :-
%    ns_suc(Am1, A) &
%    ns_mul(Am1, B, Part) &
%    ns_add(B, Part, C).
ns_add(ns(0, 0), B, B) :-
    ns_val(B).
ns_add(A, B, C) :-
    ns_suc(Am1, A) &
    ns_add(Am1, B, X) &
    ns_suc(X, C) &
    ns_val(B).
ns_suc(ns(An, As), ns(Bn, succ(As))) :-
    ns_val(ns(An, As)) &
    ns_val(ns(Bn, succ(As))).
ns_le(A, A) :-
    ns_val(A).
ns_le(A, B) :-
    ns_suc(X, B) &
    ns_le(A, X) &
    ns_val(A).
ns_eq(A, A) :-
    ns_val(A).
ns_lt(A, B) :-
    ns_le(A, B) &
    distinct(A, B).

ns_val(ns( 0, 0)).
ns_val(ns( 1, succ(0))).
ns_val(ns( 2, succ(succ(0)))).
ns_val(ns( 3, succ(succ(succ(0))))).
ns_val(ns( 4, succ(succ(succ(succ(0)))))).
ns_val(ns( 5, succ(succ(succ(succ(succ(0))))))).
ns_val(ns( 6, succ(succ(succ(succ(succ(succ(0)))))))).
ns_val(ns( 7, succ(succ(succ(succ(succ(succ(succ(0))))))))).
ns_val(ns( 8, succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))).
ns_val(ns( 9, succ(succ(succ(succ(succ(succ(succ(succ(succ(0))))))))))).
ns_val(ns(10, succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))))).

% Prolog code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Arithmetic tests
all_arithmetics_tests_are_passing :-
    all_arithmetic_predicates_always_halt,
    all_numbers_are_legal,
    all_le_tests,
    all_summation_tests.

all_numbers_are_legal :-
    \+val_generates_illegal_number(_).
val_generates_illegal_number(N) :-
    num(N), \+integer(N).

all_le_tests :-
    \+le_test_1(_,_),
    \+given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(_,_,_),
    \+there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(_,_).
le_test_1(A, B) :-
    le(A, B), le(B, A), A \= B.
given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(A, B, X) :-
    le(A, B), A \= B, le(X, A), le(B, X).
there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(A, X) :-
    le(X, A), le(A, X), A \= X.

all_summation_tests :-
    example_1_plus_2_equals_3,
    example_1_plus_2_is_never_equal_to_any_number_other_than_3,
    sum_of_2_non_0_numbers_is_never_less_then_any_of_summands.
example_1_plus_2_equals_3 :-
    add(1, 2, 3).
example_1_plus_2_is_never_equal_to_any_number_other_than_3 :-
    \+example_1_plus_2_is_equal_to_a_number_other_than_3(_).
example_1_plus_2_is_equal_to_a_number_other_than_3(C) :-
    add(1, 2, C), C \= 3.
sum_of_2_non_0_numbers_is_never_less_then_any_of_summands :-
    \+sum_of_2_non_0_numbers_is_less_then_any_of_summands(_,_,_).
sum_of_2_non_0_numbers_is_less_then_any_of_summands(A,B,C) :-
    add(A, B, C),
    A \= 0,
    B \= 0,
    (
        le(C, A);
        le(C, A)
    ).

all_arithmetic_predicates_always_halt :-
    always_halts(num(_)),
    always_halts(eq(_, _)),
    always_halts(le(_, _)),
    always_halts(lt(_, _)),
    always_halts(add(_, _, _)),
   *always_halts(mul(_, _, _)),
   *always_halts(pow(_, _, _)).

% Input tests
all_input_tests_are_passing :-
    no_player_can_move_0_pawns,
    only_random_role_can_roll_dice,
    player_can_move_to_neighboring_cell_only.

player_can_move_to_neighboring_cell_only :-
    \+there_is_a_move_to_a_distant_cell(_,_).
there_is_a_move_to_a_distant_cell(Role, Move) :-
    role(Role),
    Move = move(_, from(A), to(B)),
    input(Role, Move),
    \+neighboring_rc(A, B).
only_random_role_can_roll_dice :-
    \+there_is_different_from_random_role_that_can_roll_dice(_).
there_is_different_from_random_role_that_can_roll_dice(R) :-
    role(R), input(R, roll(_)), R \= random.

no_player_can_move_0_pawns :-
    \+player_can_move_0_pawns(_).
player_can_move_0_pawns(P) :-
    player(P),
    input(P, move(0, _)).

% Rules tests
% TODO: Perform tests for all possible board configurations
valid_board_configuration :-
    asserta.

% TODO: All players have at least 1 legal move in current non-terminal state
all_statements_about_current_configuration_are_valid :-
    \+invalid_statement_for_current_configuration_exists(_).
invalid_statement_for_current_configuration_exists(I) :-
    true(I),
    \+base(I).

max_possible_pawn_stack_is_ok_for_the_current_configuration :-
    \+there_is_a_discrepancy_for_max_possible_pawn_stack_predicate_with_a_reference_implementation(_,_,_).
there_is_a_discrepancy_for_max_possible_pawn_stack_predicate_with_a_reference_implementation(Player, MaxPawnStack, ReferenceMaxPawnStack) :-
    max_possible_pawn_stack(Player, MaxPawnStack),
    reference_max_possible_pawn_stack(Player, ReferenceMaxPawnStack),
    MaxPawnStack \= ReferenceMaxPawnStack.

reference_max_possible_pawn_stack(Player, Max) :-
    findall(N, possible_pawn_stack(Player, N), Army) &
    max_list_element(Army, Max).

all_legal_moves_for_current_configuration_are_valid :-
    \+invalid_but_legal_move_for_current_configuration_exists(_, _).
invalid_but_legal_move_for_current_configuration_exists(Role, Move) :-
    legal(Role, Move),
    \+input(Role, Move).

all_roles_have_a_score_for_current_configuration :-
    \+there_is_a_role_without_a_score_for_current_configuration(_).
there_is_a_role_without_a_score_for_current_configuration(Role) :-
    role(Role),
    \+goal(Role, _).

all_scores_are_unambiguous_for_current_configuration :-
    \+there_is_a_role_with_ambiguous_score(_).
there_is_a_role_with_ambiguous_score(Role) :-
    role(Role),
    \+role_scores_are_unambiguous(Role).
role_scores_are_unambiguous(Role) :-
    findall(Score, (goal(Role, Score)), AllScores),
    list_of_identical_values(AllScores).

current_state_is_not_terminal :-
    \+terminal.

all_rules_tests_are_passing :-
    rules_should_terminate_if_count_is_set_but_dice_list_is_not(_, _),
    rules_should_terminate_if_dice_list_is_set_but_count_is_not(_, _),
    all_rules(red-on(field, wild), [6,6,1,1], [situation(army(of(red), count( succ(succ(succ(succ(0)))) )), on(field,wild))]),
    all_rules(red-on(field, wild), [2,1,1,4], [situation(army(of(red), count( succ(succ(0))  )), on(field,owned_by(red)))]),
    all_rules(red-on(field, wild), [1,2,5,6], [situation(army(of(red), count( succ(succ(succ(0))) )), on(field,owned_by(red)))]),
    all_rules(red-on(field, owned_by(red)), [1], [situation(army(of(red), count( succ(0) )), on(field,owned_by(red)))]).

rules_should_terminate_if_count_is_set_but_dice_list_is_not(L0, L1) :-
    findall(D, (nrules(situation(army(of(red), count(0)), on(field, wild)), D, _)), L0),
    findall(D, (nrules(situation(army(of(red), count(1)), on(field, wild)), D, _)), L1).
rules_should_terminate_if_dice_list_is_set_but_count_is_not(L0, L1) :-
    findall(Before, (nrules(Before, dice([]), _)), L0),
    findall(Before, (nrules(Before, dice([1]), _)), L1).
all_rules(Player-On, Dice, AllPossibleOutcomes) :-
    findall(After, nrules(situation(army(of(Player), count(_)), On), dice(Dice), After), AllPossibleOutcomes).

all_tests_are_passing :-
    all_statements_about_current_configuration_are_valid,
    max_possible_pawn_stack_is_ok_for_the_current_configuration,
    all_legal_moves_for_current_configuration_are_valid,
    all_roles_have_a_score_for_current_configuration,
    all_scores_are_unambiguous_for_current_configuration,
    current_state_is_not_terminal,
   *all_rules_tests_are_passing,
    all_arithmetics_tests_are_passing,
    all_input_tests_are_passing.

list_of_identical_values([]).
list_of_identical_values([H|T]) :-
    value_of_all_elements_of_a_list(H, T).
value_of_all_elements_of_a_list(_, []).
value_of_all_elements_of_a_list(H, [H|T]) :-
    value_of_all_elements_of_a_list(H, T).

always_halts(Goal) :-
    \+doesnt_halt(Goal).
doesnt_halt(Goal) :-
    call(Goal), false.

max_list_element([Max], Max).
max_list_element([H|T], Max) :-
    max_list_element(T, PrevMax),
    max(H, PrevMax, Max).

max(A, B, A) :- A > B.
max(A, B, B) :- B >= A.

% Assert that current configuration is initial
true(X) :- init(X).

'&'(Lhs, Rhs) :-
    call(Lhs), call(Rhs).
'|'(Lhs, Rhs) :-
    call(Lhs) ; call(Rhs).
'~'(Rhs) :-
    \+ call(Rhs).
'*'(_).

'$'(Goal) :-
    portray_clause(call:Goal) ->
        $-Goal ~>
            portray_clause(exit:Goal).

'$-'(Goal) :-
    catch(
        Goal,
        Exception,
        (
            portray_clause(excp:Exception:Goal) ->
                throw(Exception)
        )
    ).

'?'(Goal) :-
    call(Goal) ~>
        portray_clause(fail:Goal) ->
            false.

% FIXME: Don't call Cond twice
'~>'(Cond, IfFailed) :-
    \+call(Cond) ->
        call(IfFailed);
        call(Cond).

% FIXME: It looks like distinct/2 should behave like dif/2
distinct(A, B) :- A \= B.
