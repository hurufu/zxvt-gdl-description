% Not quite Capture of the Territory
% 1 player
% Board 3Ã—3
% No buildings
% Pawns can't be stacked and only single pawn can be placed on the board
% Goal is to capture the whole board

% WARNING: Remove to get valid program in GDL-II (HRF)
:- op(1000, xfy, '&').
:- op(1100, xfy, '|').
:- op(900, fy, '~').
:- op(950, fy, '*').
:- op(900, fy, '$').
:- op(900, fy, '$-').
:- initialization(all_tests_are_passing).

% Configuration
max_row(3).
max_col(3).
max_stack(1).
start_position(red, rc(1,1)).
rich_ui(no_rich_ui).%Avoid exception if all UI enrichments are disabled
rich_ui(last_roll).
rules(Player, captured_by(Player), [nothing,  nothing, nothing, nothing, nothing, nothing]) :- player(Player).
rules(Player, wild,                [minusone, nothing, nothing, capture, capture, capture]) :- player(Player).

% TODO: Consider something similar as a future rules
rules(situation(army(of(P), count(     X )), on(Tile,  owned_by(P))), die(D), situation(army(of(P), count(     X )), on(Tile,  owned_by(P)))) :- player(P) & valid_tile(Tile) & d6(D) & is_succ(X).
rules(situation(army(of(P), count(succ(X))), on(field,        wild)), die(1), situation(army(of(P), count(     X )), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(2), situation(army(of(P), count(     X )), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(3), situation(army(of(P), count(     X )), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(4), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(5), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field,        wild)), die(6), situation(army(of(P), count(succ(X))), on(field,        wild))) :- player(P) & is_succ(X).
rules(situation(army(of(P), count(succ(X))), on(field, owned_by(Q))), die(1), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(2), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(3), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(4), situation(army(of(P), count(     X )), on(field, owned_by(Q)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(5), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
rules(situation(army(of(P), count(     X )), on(field, owned_by(Q))), die(6), situation(army(of(P), count(     X )), on(field, owned_by(P)))) :- player(P) & player(Q) & distinct(P, Q) & is_succ(X).
%rules(situation(army(of(P), count(X)), on(town,  owned_by(Q))), die(D), situation(army(of(P), count(Y)), on(town,  owned_by(Q)))) :- (D = 1; D = 2), Y #= X-1, P \= Q.
%rules(situation(army(of(P), count(X)), on(town,  owned_by(Q))), die(D), situation(army(of(P), count(X)), on(town,  owned_by(Q)))) :- (D = 3; D = 4), P \= Q.
%rules(situation(army(of(P), count(X)), on(town,  owned_by(Q))), die(D), situation(army(of(P), count(X)), on(town,  owned_by(P)))) :- (D = 5; D = 6), P \= Q.

% GDL
role(random).
role(red).

% Number of rolled dice shouldn't exceed allowed pawn stack size
input(random, roll(L)) :-
    roll_d6(M, L) &
    stack(M).
input(Player, move(NumberOfPawns, from(From), to(To))) :-
    player(Player) &
    stack(NumberOfPawns) &
    neighboring_coordinates(From, To).
% New pawn can be spawned only at player's starting position
input(Player, spawn(at(StartPosition))) :-
    start_position(Player, StartPosition).

base(Cell) :- valid_cell(Cell).
base(control(R)) :- player(R).
base(last_roll(D6, Outcome)) :-
    rich_ui(last_roll) &
    d6(D6) &
    outcome(Outcome).

init(cell(StartPosition, captured_by(Player), with_pawn(of(Player), number(1)))) :-
    start_position(Player, StartPosition).
init(cell(Rc, wild, free)) :-
    valid_cell(cell(Rc, wild, free)) &
    start_position(_, StartPosition) &
    distinct(StartPosition, Rc).
init(control(red)).

% TODO: Number of dice thrown should be equal to the largest player's pawn stack
legal(random, roll([D6])) :-
    true(control(Player)) &
    player(Player) &
    d6(D6).
legal(Player, move(MovingPawns, from(From), to(To))) :-
    true(control(Player)) &
    true(cell(From, _, with_pawn(of(Player), number(StationaryPawns)))) &
    player(Player) &
    neighboring_coordinates(From, To) &
    stack(MovingPawns) &
    le(MovingPawns, StationaryPawns).
legal(Player, spawn(at(rc(1,1)))) :-
    true(control(Player)) &
    true_for_each_cell_occupation(free).

goal(random, 0).
goal(Player, Score) :-
    player_score(Player, Score).

% Games ends if all board is captured
terminal :-
    player(Player) &
    true_for_each_cell(captured_by(Player)).

% TODO: Game ends if an opposite side of a board is captured
%terminal :-
%    player(red) &
%    cell(rc(3,3), captured_by(red), _).

next(cell(FromAndTo, captured_by(Player), with_pawn(of(Player), number(MovingPawns)))) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, capture).

next(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, nothing).

next(cell(FromAndTo, OldCapture, free)) :-
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(FromAndTo), to(FromAndTo))) &
    true(cell(FromAndTo, OldCapture, with_pawn(of(Player), number(MovingPawns)))) &
    rule_outcome(Player, D, OldCapture, minusone).

% Destination is captured by player according to rule book and all pawns appear there
next(cell(To, captured_by(Player), with_pawn(of(Player), number(MovingPawns)))) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D, Capture, capture).

next(cell(To, Capture, with_pawn(of(Player), number(MovingPawns)))) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(MovingPawns, from(From), to(To))) &
    distinct(From, To) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D, Capture, nothing).

next(cell(To, Capture, free)) :-
    player(Player) &
    does(random, roll([D])) &
    does(Player, move(_, from(From), to(To))) &
    true(cell(To, Capture, _)) &
    distinct(From, To) &
    rule_outcome(Player, D, Capture, minusone).

% Origin retains its capture state and ALL pawns are removed
next(cell(From, OldCapture, free)) :-
    player(Player) &
    does(random, _) &
    does(Player, move(_, from(From), to(To))) &
    distinct(From, To) &
    true(cell(From, OldCapture, _)).

% All other cells should retains their respective state
next(cell(Rc, OldCapture, OldPawnState)) :-
    player(Player) &
    does(random, _) &
    does(Player, move(_, from(From), to(To))) &
    true(cell(Rc, OldCapture, OldPawnState)) &
    distinct(Rc, From) &
    distinct(Rc, To).

% All other cells should retains their respective state
next(cell(Rc, OldCapture, OldPawnState)) :-
    does(_, spawn(at(Spawn))) &
    true(cell(Rc, OldCapture, OldPawnState)) &
    distinct(Rc, Spawn).

next(cell(Spawn, OldCapture, with_pawn(of(Player), number(1)))) :-
    does(Player, spawn(at(Spawn))) &
    true(cell(Spawn, OldCapture, _)).

% There is no transfer of control
next(control(Player)) :-
    player(Player) &
    true(control(Player)).

next(last_roll(D6, Outcome)) :-
    rich_ui(last_roll) &
    player(Player) &
    does(random, roll([D6])) &
    does(Player, move(_, from(_), to(To))) &
    true(cell(To, Capture, _)) &
    rule_outcome(Player, D6, Capture, Outcome).

% Input utils
player_score(Player, 100) :-
    true_for_each_cell(captured_by(Player)).
player_score(Player, 50) :-
    true(cell(_, wild, _)) &
    true(cell(_, captured_by(Player), _)).
player_score(Player, 0) :-
    player(Player) &% Fixes unsafe rule warning
    true_for_each_cell(wild).

%% TODO: Implement it in GDL
%alt_player_score(Player, NumberOfCapturedCells) :-
%    player(Player) &
%    findall(I, (I=cell(_, captured_by(Player), _), true(I)), L) &
%    length(L, NumberOfCapturedCells).

true_for_each_cell(Capture) :-
    true(cell(rc(1,1), Capture, _)) &
    true(cell(rc(1,2), Capture, _)) &
    true(cell(rc(1,3), Capture, _)) &
    true(cell(rc(2,1), Capture, _)) &
    true(cell(rc(2,2), Capture, _)) &
    true(cell(rc(2,3), Capture, _)) &
    true(cell(rc(3,1), Capture, _)) &
    true(cell(rc(3,2), Capture, _)) &
    true(cell(rc(3,3), Capture, _)).

true_for_each_cell_occupation(Occupation) :-
    true(cell(rc(1,1), _, Occupation)) &
    true(cell(rc(1,2), _, Occupation)) &
    true(cell(rc(1,3), _, Occupation)) &
    true(cell(rc(2,1), _, Occupation)) &
    true(cell(rc(2,2), _, Occupation)) &
    true(cell(rc(2,3), _, Occupation)) &
    true(cell(rc(3,1), _, Occupation)) &
    true(cell(rc(3,2), _, Occupation)) &
    true(cell(rc(3,3), _, Occupation)).

% Utils with complete definitions
row(I) :-
    max_row(MaxRow) &
    le(1, I) & le(I, MaxRow).

col(I) :-
    max_col(MaxCol) &
    le(1, I) & le(I, MaxCol).

stack(PossiblePawnStack) :-
    max_stack(MaxStack) &
    le(1, PossiblePawnStack) & le(PossiblePawnStack, MaxStack).

neighboring_coordinates(A, B) :-
    coordinates(A) &
    coordinates(B) &
    neighboring_coordinates_aux(A, B).
neighboring_coordinates_aux(rc(R,C), rc(R,C)) :- is_number(R) & is_number(C).
neighboring_coordinates_aux(rc(R,Lc), rc(R,Rc)) :- is_number(R) & s(Lc, Rc).
neighboring_coordinates_aux(rc(R,Lc), rc(R,Rc)) :- is_number(R) & s(Rc, Lc).
neighboring_coordinates_aux(rc(Lr,C), rc(Rr,C)) :- is_number(C) & s(Lr, Rr).
neighboring_coordinates_aux(rc(Lr,C), rc(Rr,C)) :- is_number(C) & s(Rr, Lr).

roll_d6(0, []).
roll_d6(1, [R1]) :- d6(R1).
roll_d6(2, [R1,R2]) :- d6(R1) & d6(R2).
roll_d6(3, [R1,R2,R3]) :- d6(R1) & d6(R2) & d6(R3).
roll_d6(4, [R1,R2,R3,R4]) :- d6(R1) & d6(R2) & d6(R3) & d6(R4).

counted_dice(dice(D6), X) :-
    roll_d6(N, D6) &
    sc(N, X).

head_tail_of_dice(R1, [], dice([R1])) :- roll_d6(_, [R1]).
head_tail_of_dice(R1, [R2], dice([R1,R2])) :- roll_d6(_, [R1,R2]).
head_tail_of_dice(R1, [R2,R3], dice([R1,R2,R3])) :- roll_d6(_, [R1,R2,R3]).
head_tail_of_dice(R1, [R2,R3,R4], dice([R1,R2,R3,R4])) :- roll_d6(_, [R1,R2,R3,R4]).

nth_element_d6(1, [R1,R2,R3,R4,R5,R6], R1) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(2, [R1,R2,R3,R4,R5,R6], R2) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(3, [R1,R2,R3,R4,R5,R6], R3) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(4, [R1,R2,R3,R4,R5,R6], R4) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(5, [R1,R2,R3,R4,R5,R6], R5) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).
nth_element_d6(6, [R1,R2,R3,R4,R5,R6], R6) :- outcome(R1) & outcome(R2) & outcome(R3) & outcome(R4) & outcome(R5) & outcome(R6).

outcome(capture).
outcome(nothing).
outcome(minusone).

valid_situation_0(situation(army(of(Player), count(0)), On)) :-
    valid_situation(situation(nobody, On)) &
    player(Player).
valid_situation(situation(Occupation, on(Tile,  Ownership))) :-
    valid_occupation(Occupation) &
    valid_tile(Tile) &
    valid_ownerhip(Ownership).

valid_tile(field).
%valid_tile(town).
valid_ownerhip(wild).
valid_ownerhip(owned_by(Player)) :-
    player(Player).
valid_occupation(nobody).
valid_occupation(army(of(Player), count(X))) :-
    player(Player) &
    is_succ(X).

unify_situation(A, A) :-
    valid_situation(A).
unify_dice(dice(A), dice(A)) :-
    roll_d6(_, A).
count_of_situation(situation(army(Of, count(X)), On), X) :-
    valid_situation(situation(army(Of, count(X)), On)).

nrules(S, dice([]), S) :-
    valid_situation_0(S).
nrules(Before, Roll, situation(army(ReturnArmy, count(A)), ReturnOn)) :-
    head_tail_of_dice(D6, T, Roll) &
    counted_dice(Roll, succ(N)) &
    count_of_situation(Before, succ(N)) &
    rules(Before, die(D6), situation(army(Of, count(C)), On)) &
    unify_dice(dice(T), DiceTail) &
    nrules(Next, DiceTail, Return) &
    add(A, succ(N), Tmp) & add(succ(R), C, Tmp) &
    valid_situation(situation(army(ReturnArmy, count(A)), ReturnOn)) &
    unify_situation(situation(army(Of, count(N)), On), Next) &
    unify_situation(situation(army(ReturnArmy, count(R)), ReturnOn), Return).

nrules_outcome(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(nobody, On)) :-
    nrules(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(_, count(0)), On)).
nrules_outcome(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(OfAfter, count(succ(A))), OnAfter)) :-
    nrules(situation(army(OfBefore, count(succ(B))), OnBefore), Roll, situation(army(OfAfter, count(succ(A))), OnAfter)).

rule_outcome(Player, D6, CaptureType, Outcome) :-
    rules(Player, CaptureType, OutcomeList) &
    nth_element_d6(D6, OutcomeList, Outcome).

player(Player) :-
    role(Player) &
    distinct(random, Player).

valid_cell(cell(Coordinates, Type, WithPawn)) :-
    coordinates(Coordinates) &
    cell_type(Type) &
    valid_pawn(WithPawn).

coordinates(rc(Row, Column)) :- row(Row) & col(Column).

cell_type(wild).
cell_type(captured_by(Player)) :-
    player(Player).
valid_pawn(free).
valid_pawn(with_pawn(of(Player), number(Number))) :-
    player(Player) &
    stack(Number).

% Dice utils
d6(1). d6(2). d6(3). d6(4). d6(5). d6(6).
roll_d6(N, L) :- type_nl(d6, nl(N, L)).
head_tail_of_dice(H, T, dice(L)) :- type_list_head_tail(d6, L, H, T).
counted_dice(dice(L), N) :- type_nl(d6, nl(N, L)).

% List utils
type(d6).
type(outcome).
type_element(d6, Element) :- d6(Element).
type_element(outcome, Element) :- outcome(Element).

type_nl_00(Tp, []) :- type(Tp).
type_nl_01(Tp, [H]) :- type_element(Tp, H) & type_nl_00(Tp, []).
type_nl_02(Tp, [H,T1]) :- type_element(Tp, H) & type_nl_01(Tp, [T1]).
type_nl_03(Tp, [H,T1,T2]) :- type_element(Tp, H) & type_nl_02(Tp, [T1,T2]).
type_nl_04(Tp, [H,T1,T2,T3]) :- type_element(Tp, H) & type_nl_03(Tp, [T1,T2,T3]).
type_nl_05(Tp, [H,T1,T2,T3,T4]) :- type_element(Tp, H) & type_nl_04(Tp, [T1,T2,T3,T4]).
type_nl_06(Tp, [H,T1,T2,T3,T4,T5]) :- type_element(Tp, H) & type_nl_05(Tp, [T1,T2,T3,T4,T5]).
type_nl(Tp, nl(0, [])) :- type_nl_00(Tp, []).
type_nl(Tp, nl(1, [H])) :- type_nl_01(Tp, [H]).
type_nl(Tp, nl(2, [H,T1])) :- type_nl_02(Tp, [H,T1]).
type_nl(Tp, nl(3, [H,T1,T2])) :- type_nl_03(Tp, [H,T1,T2]).
type_nl(Tp, nl(4, [H,T1,T2,T3])) :- type_nl_04(Tp, [H,T1,T2,T3]).
type_nl(Tp, nl(5, [H,T1,T2,T3,T4])) :- type_nl_05(Tp, [H,T1,T2,T3,T4]).
type_nl(Tp, nl(6, [H,T1,T2,T3,T4,T5])) :- type_nl_06(Tp, [H,T1,T2,T3,T4,T5]).
%type_list_head_tail(Tp, H!T,  H, T) :- type_nl(Tp, nl(_,  H!T )).
type_list_head_tail(Tp, [H|T], H, T) :- type_nl(Tp, nl(_, [H|T])).

nth_element(Tp, 1, L, H) :-
    type_list_head_tail(Tp, L, H, _).
nth_element(Tp, N, L, E) :-
    type_list_head_tail(Tp, L, _, T) &
    add(ns(1, _), ns(M, _), ns(N, _)) &
    nth_element(Tp, M, T, E).

% Arithmetic utils
is_number(N) :- is_ns(ns(N, _)).
is_succ(S) :- is_ns(ns(_, S)).

le(A, A) :- is_ns(A).
le(A, B) :-
    suc(X, B) &
    le(A, X).
uni(A, A) :- is_ns(A).
suc(A, B) :-
    uni(A, ns(_, As)) &
    uni(B, ns(_, succ(As))).
add(ns(0,0), B, B) :- is_ns(B).
add(A, B, C) :-
    suc(Am1, A) &
    add(Am1, B, X) &
    suc(X, C) &
    is_ns(B).

is_ns(ns( 0, 0)).
is_ns(ns( 1, succ(0))).
is_ns(ns( 2, succ(succ(0)))).
is_ns(ns( 3, succ(succ(succ(0))))).
is_ns(ns( 4, succ(succ(succ(succ(0)))))).
is_ns(ns( 5, succ(succ(succ(succ(succ(0))))))).
is_ns(ns( 6, succ(succ(succ(succ(succ(succ(0)))))))).
is_ns(ns( 7, succ(succ(succ(succ(succ(succ(succ(0))))))))).
is_ns(ns( 8, succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))).
is_ns(ns( 9, succ(succ(succ(succ(succ(succ(succ(succ(succ(0))))))))))).
is_ns(ns(10, succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))))).

% Prolog code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Arithmetic tests
all_arithmetics_tests_are_passing :-
    all_arithmetic_predicates_always_halt,
    all_numbers_are_legal,
    all_le_tests,
    all_addition_tests.

all_numbers_are_legal :-
    \+is_number_generates_illegal_number(_).
is_number_generates_illegal_number(N) :-
    is_number(N), \+number(N).

all_le_tests :-
    \+le_test_1(_,_),
    \+given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(_,_,_),
    \+there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(_,_).
le_test_1(A, B) :-
    le(A, B), le(B, A), A \= B.
given_two_non_equal_numbers_there_is_a_number_that_is_both_larger_than_the_largest_one_and_smaller_than_the_smallest_one(A, B, X) :-
    le(A, B), A \= B, le(X, A), le(B, X).
there_is_a_number_that_is_both_strictly_larger_and_smaller_than_any_given_one(A, X) :-
    le(X, A), le(A, X), A \= X.

all_addition_tests :-
    example_1_plus_2_equals_3,
    example_1_plus_2_is_never_equal_to_any_number_other_than_3,
    sum_of_2_non_0_numbers_is_never_less_then_any_of_summands.
example_1_plus_2_equals_3 :-
    add(ns(1, _), ns(2, _), ns(3, _)).
example_1_plus_2_is_never_equal_to_any_number_other_than_3 :-
    \+example_1_plus_2_is_equal_to_a_number_other_than_3(_).
example_1_plus_2_is_equal_to_a_number_other_than_3(C) :-
    add(ns(1, _), ns(2, _), C), C \= ns(3, _).
sum_of_2_non_0_numbers_is_never_less_then_any_of_summands :-
    \+sum_of_2_non_0_numbers_is_less_then_any_of_summands(_,_,_).
sum_of_2_non_0_numbers_is_less_then_any_of_summands(A,B,C) :-
    add(A, B, C),
    A \= ns(0,0),
    B \= ns(0,0),
    (
        le(C, A);
        le(C, A)
    ).

all_arithmetic_predicates_always_halt :-
    always_halts(is_number(_)),
    always_halts(is_succ(_)),
    always_halts(uni(_, _)),
    always_halts(le(_, _)),
    always_halts(suc(_, _)),
    always_halts(add(_, _, _)).

% Rules tests
% TODO: Perform tests for all possible board configurations
% TODO: All players have at least 1 legal move in current non-terminal state
all_statements_about_current_configuration_are_valid :-
    \+invalid_statement_for_current_configuration_exists(_).
invalid_statement_for_current_configuration_exists(I) :-
    true(I),
    \+base(I).

all_legal_moves_for_current_configuration_are_valid :-
    \+invalid_but_legal_move_for_current_configuration_exists(_, _).
invalid_but_legal_move_for_current_configuration_exists(Role, Move) :-
    legal(Role, Move),
    \+input(Role, Move).

all_roles_have_a_score_for_current_configuration :-
    \+there_is_a_role_without_a_score_for_current_configuration(_).
there_is_a_role_without_a_score_for_current_configuration(Role) :-
    role(Role),
    \+goal(Role, _).

all_scores_are_unambiguous_for_current_configuration :-
    \+there_is_a_role_with_ambiguous_score(_).
there_is_a_role_with_ambiguous_score(Role) :-
    role(Role),
    \+role_scores_are_unambiguous(Role).
role_scores_are_unambiguous(Role) :-
    findall(Score, (goal(Role, Score)), AllScores),
    list_of_identical_values(AllScores).

user_cannot_move_0_pawns :-
    \+pawn_0.
pawn_0 :-
    stack(NumberOfAllowedPawns),
    \+le(0, NumberOfAllowedPawns).

current_state_is_not_terminal :-
    \+terminal.

all_rules_tests_are_passing :-
    rules_should_terminate_if_count_is_set_but_dice_list_is_not(_, _),
    rules_should_terminate_if_dice_list_is_set_but_count_is_not(_, _),
    all_rules(red-on(field, wild), [6,6,1,1], [situation(army(of(red), count( succ(succ(succ(succ(0)))) )), on(field,wild))]),
    all_rules(red-on(field, wild), [2,1,1,4], [situation(army(of(red), count( succ(succ(0))  )), on(field,owned_by(red)))]),
    all_rules(red-on(field, wild), [1,2,5,6], [situation(army(of(red), count( succ(succ(succ(0))) )), on(field,owned_by(red)))]),
    all_rules(red-on(field, owned_by(red)), [1], [situation(army(of(red), count( succ(0) )), on(field,owned_by(red)))]).

rules_should_terminate_if_count_is_set_but_dice_list_is_not(L0, L1) :-
    findall(D, (nrules(situation(army(of(red), count(0)), on(field, wild)), D, _)), L0),
    findall(D, (nrules(situation(army(of(red), count(1)), on(field, wild)), D, _)), L1).
rules_should_terminate_if_dice_list_is_set_but_count_is_not(L0, L1) :-
    findall(Before, (nrules(Before, dice([]), _)), L0),
    findall(Before, (nrules(Before, dice([1]), _)), L1).
all_rules(Player-On, Dice, AllPossibleOutcomes) :-
    findall(After, nrules(situation(army(of(Player), count(_)), On), dice(Dice), After), AllPossibleOutcomes).

all_tests_are_passing :-
   *all_statements_about_current_configuration_are_valid,
   *all_legal_moves_for_current_configuration_are_valid,
   *all_roles_have_a_score_for_current_configuration,
   *all_scores_are_unambiguous_for_current_configuration,
   *current_state_is_not_terminal,
   *all_rules_tests_are_passing,
    all_arithmetics_tests_are_passing,
   *user_cannot_move_0_pawns.

list_of_identical_values([]).
list_of_identical_values([H|T]) :-
    value_of_all_elements_of_a_list(H, T).
value_of_all_elements_of_a_list(_, []).
value_of_all_elements_of_a_list(H, [H|T]) :-
    value_of_all_elements_of_a_list(H, T).

always_halts(Goal) :-
    \+doesnt_halt(Goal).
doesnt_halt(Goal) :-
    call(Goal), false.

% Assert that current configuration is initial
true(X) :- init(X).

'&'(Lhs, Rhs) :-
    call(Lhs), call(Rhs).
'|'(Lhs, Rhs) :-
    call(Lhs) ; call(Rhs).
'~'(Rhs) :-
    \+ call(Rhs).
'*'(_).

'$_error_stream'(user_error).
'$'(Goal) :-
    '$_error_stream'(ErrorStream),
    portray_clause(ErrorStream, call:Goal),
    $-Goal,
    portray_clause(ErrorStream, exit:Goal).
'$-'(Goal) :-
    '$_error_stream'(ErrorStream),
    catch(
        Goal,
        Exception,
        (
            portray_clause(ErrorStream, excp:Exception:Goal),
            throw(Exception)
        )
    ).

% FIXME: It looks like distinct/2 should behave like dif/2
distinct(A, B) :- A \= B.
